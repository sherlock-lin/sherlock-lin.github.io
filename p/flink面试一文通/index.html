<!DOCTYPE html>
<html lang="zh-cn" dir="ltr">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content="高频 基本 简单介绍一下 Flink Flink 是一个框架和分布式处理引擎，用于对无界和有界数据流进行有状态计算。并且 Flink 提供了数据分布、容错机制以及资源管理等核心功能。Flink提供了诸多高抽象层的API以便用户编写分布式任务：\n">
<title>Flink面试一文通</title>

<link rel='canonical' href='https://sherlock-lin.github.io/p/flink%E9%9D%A2%E8%AF%95%E4%B8%80%E6%96%87%E9%80%9A/'>

<link rel="stylesheet" href="/scss/style.min.663803bebe609202d5b39d848f2d7c2dc8b598a2d879efa079fa88893d29c49c.css"><meta property='og:title' content="Flink面试一文通">
<meta property='og:description' content="高频 基本 简单介绍一下 Flink Flink 是一个框架和分布式处理引擎，用于对无界和有界数据流进行有状态计算。并且 Flink 提供了数据分布、容错机制以及资源管理等核心功能。Flink提供了诸多高抽象层的API以便用户编写分布式任务：\n">
<meta property='og:url' content='https://sherlock-lin.github.io/p/flink%E9%9D%A2%E8%AF%95%E4%B8%80%E6%96%87%E9%80%9A/'>
<meta property='og:site_name' content='夏洛克-林'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:published_time' content='2025-03-12T11:52:29&#43;08:00'/><meta property='article:modified_time' content='2025-03-12T11:52:29&#43;08:00'/><meta property='og:image' content='https://sherlock-lin.github.io/p/flink%E9%9D%A2%E8%AF%95%E4%B8%80%E6%96%87%E9%80%9A/leaf-8687801_1280.jpg' />
<meta name="twitter:title" content="Flink面试一文通">
<meta name="twitter:description" content="高频 基本 简单介绍一下 Flink Flink 是一个框架和分布式处理引擎，用于对无界和有界数据流进行有状态计算。并且 Flink 提供了数据分布、容错机制以及资源管理等核心功能。Flink提供了诸多高抽象层的API以便用户编写分布式任务：\n"><meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content='https://sherlock-lin.github.io/p/flink%E9%9D%A2%E8%AF%95%E4%B8%80%E6%96%87%E9%80%9A/leaf-8687801_1280.jpg' />
    </head>
    <body class="
    article-page
    ">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky ">
    <button class="hamburger hamburger--spin" type="button" id="toggle-menu" aria-label="切换菜单">
        <span class="hamburger-box">
            <span class="hamburger-inner"></span>
        </span>
    </button>

    <header>
        
            
            <figure class="site-avatar">
                <a href="/">
                
                    
                    
                    
                        
                        <img src="/img/cs_hu10005534405353342465.jpg" width="300"
                            height="294" class="site-logo" loading="lazy" alt="Avatar">
                    
                
                </a>
                
                    <span class="emoji">🥳</span>
                
            </figure>
            
        
        
        <div class="site-meta">
            <h1 class="site-name"><a href="/">夏洛克-林</a></h1>
            <h2 class="site-description">欢迎来到一个读书狂魔、偏执狂的博客~</h2>
        </div>
    </header><ol class="menu-social">
            
                <li>
                    <a 
                        href='https://github.com/CaiJimmy/hugo-theme-stack'
                        target="_blank"
                        title="GitHub"
                        rel="me"
                    >
                        
                        
                            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M9 19c-4.3 1.4 -4.3 -2.5 -6 -3m12 5v-3.5c0 -1 .1 -1.4 -.5 -2c2.8 -.3 5.5 -1.4 5.5 -6a4.6 4.6 0 0 0 -1.3 -3.2a4.2 4.2 0 0 0 -.1 -3.2s-1.1 -.3 -3.5 1.3a12.3 12.3 0 0 0 -6.2 0c-2.4 -1.6 -3.5 -1.3 -3.5 -1.3a4.2 4.2 0 0 0 -.1 3.2a4.6 4.6 0 0 0 -1.3 3.2c0 4.6 2.7 5.7 5.5 6c-.6 .6 -.6 1.2 -.5 2v3.5" />
</svg>



                        
                    </a>
                </li>
            
                <li>
                    <a 
                        href='https://twitter.com'
                        target="_blank"
                        title="Twitter"
                        rel="me"
                    >
                        
                        
                            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-twitter" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M22 4.01c-1 .49 -1.98 .689 -3 .99c-1.121 -1.265 -2.783 -1.335 -4.38 -.737s-2.643 2.06 -2.62 3.737v1c-3.245 .083 -6.135 -1.395 -8 -4c0 0 -4.182 7.433 4 11c-1.872 1.247 -3.739 2.088 -6 2c3.308 1.803 6.913 2.423 10.034 1.517c3.58 -1.04 6.522 -3.723 7.651 -7.742a13.84 13.84 0 0 0 .497 -3.753c-.002 -.249 1.51 -2.772 1.818 -4.013z" />
</svg>



                        
                    </a>
                </li>
            
        </ol><ol class="menu" id="main-menu">
        
        
        
        <li >
            <a href='/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="5 12 3 12 12 3 21 12 19 12" />
  <path d="M5 12v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-7" />
  <path d="M9 21v-6a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v6" />
</svg>



                
                <span>主页</span>
            </a>
        </li>
        
        
        <li >
            <a href='/%E5%85%B3%E4%BA%8E/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="7" r="4" />
  <path d="M6 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2" />
</svg>



                
                <span>关于</span>
            </a>
        </li>
        
        
        <li >
            <a href='/archives/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <rect x="3" y="4" width="18" height="4" rx="2" />
  <path d="M5 8v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-10" />
  <line x1="10" y1="12" x2="14" y2="12" />
</svg>



                
                <span>归档</span>
            </a>
        </li>
        
        
        <li >
            <a href='/search/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="10" cy="10" r="7" />
  <line x1="21" y1="21" x2="15" y2="15" />
</svg>



                
                <span>搜索</span>
            </a>
        </li>
        
        
        <li >
            <a href='/%E5%8F%8B%E6%83%85%E9%93%BE%E6%8E%A5/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M10 14a3.5 3.5 0 0 0 5 0l4 -4a3.5 3.5 0 0 0 -5 -5l-.5 .5" />
  <path d="M14 10a3.5 3.5 0 0 0 -5 0l-4 4a3.5 3.5 0 0 0 5 5l.5 -.5" />
</svg>



                
                <span>友情链接</span>
            </a>
        </li>
        
        <li class="menu-bottom-section">
            <ol class="menu">

                
                    <li id="dark-mode-toggle">
                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="8" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="16" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <span>暗色模式</span>
                    </li>
                
            </ol>
        </li>
    </ol>
</aside>

    <aside class="sidebar right-sidebar sticky">
        
            
                
    <section class="widget archives">
        <div class="widget-icon">
            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <line x1="5" y1="9" x2="19" y2="9" />
  <line x1="5" y1="15" x2="19" y2="15" />
  <line x1="11" y1="4" x2="7" y2="20" />
  <line x1="17" y1="4" x2="13" y2="20" />
</svg>



        </div>
        <h2 class="widget-title section-title">目录</h2>
        
        <div class="widget--toc">
            <nav id="TableOfContents">
  <ol>
    <li><a href="#高频">高频</a></li>
    <li><a href="#基本">基本</a>
      <ol>
        <li><a href="#简单介绍一下-flink">简单介绍一下 Flink</a></li>
        <li><a href="#flink的主要特点是什么">Flink的主要特点是什么？</a></li>
        <li><a href="#flink的应用场景有哪些">Flink的应用场景有哪些？</a>
          <ol>
            <li><a href="#4flink编程模型是什么">4、Flink编程模型是什么？</a></li>
            <li><a href="#5讲一下flink的运行架构flink集群有哪些角色各自有什么作用">5、讲一下Flink的运行架构，Flink集群有哪些角色？各自有什么作用？</a></li>
            <li><a href="#6flink的集群部署模式有哪些">6、Flink的集群部署模式有哪些？</a></li>
            <li><a href="#7你们之前flink集群规模有多大">7、你们之前Flink集群规模有多大？</a></li>
            <li><a href="#8说说flink集群优化">8、说说Flink集群优化</a></li>
            <li><a href="#9公司怎么提交的实时任务有多少job-manager">9、公司怎么提交的实时任务，有多少Job Manager？</a></li>
            <li><a href="#10flink的并行度了解吗flink的并行度设置是怎样的">10、Flink的并行度了解吗？Flink的并行度设置是怎样的？</a></li>
            <li><a href="#11flink的checkpoint存在哪里">11、Flink的Checkpoint存在哪里？</a></li>
            <li><a href="#12flink的checkpoint机制对比spark有什么不同和优势">12、Flink的checkpoint机制对比spark有什么不同和优势？</a></li>
            <li><a href="#13flink常用的算子有哪些">13、Flink常用的算子有哪些？</a></li>
            <li><a href="#14flink的流式处理如何处理延迟">14、Flink的流式处理如何处理延迟？</a></li>
            <li><a href="#15flink-中对窗口的支持包括哪几种说说他们的使用场景">15、Flink 中对窗口的支持包括哪几种？说说他们的使用场景</a></li>
            <li><a href="#16flink支持哪些第三方集成">16、Flink支持哪些第三方集成？</a></li>
            <li><a href="#17flink的source和sink有哪些">17、Flink的source和sink有哪些？</a></li>
            <li><a href="#18flink支持哪些批处理操作">18、Flink支持哪些批处理操作？</a></li>
            <li><a href="#19flink的流处理和批处理如何切换">19、Flink的流处理和批处理如何切换？</a></li>
            <li><a href="#20为什么使用-flink-替代-spark">20、为什么使用 Flink 替代 Spark？</a></li>
            <li><a href="#21说说flink-的容错机制flink是如何做到容错的">21、说说Flink 的容错机制，Flink是如何做到容错的？</a></li>
            <li><a href="#22flink是如何做到高效的网络数据交换的">22、Flink是如何做到高效的网络数据交换的？</a></li>
            <li><a href="#23flink程序在面对数据高峰期时如何处理">23、Flink程序在面对数据高峰期时如何处理？</a></li>
            <li><a href="#24flink分布式快照的原理是什么">24、Flink分布式快照的原理是什么？</a></li>
            <li><a href="#25flink跟spark-streaming的区别">25、Flink跟Spark Streaming的区别</a></li>
            <li><a href="#26说说flink的几种时间语义">26、说说Flink的几种时间语义</a></li>
            <li><a href="#27说说flink中的watermark机制">27、说说Flink中的Watermark机制</a></li>
            <li><a href="#28flink怎么做压力测试和监控">28、Flink怎么做压力测试和监控？</a></li>
            <li><a href="#29flink是通过什么机制实现的背压机制">29、Flink是通过什么机制实现的背压机制？</a></li>
            <li><a href="#30flink是如何处理反压的如何监控和发现">30、Flink是如何处理反压的？如何监控和发现？</a></li>
            <li><a href="#31flink中的window出现了数据倾斜你有什么解决办法">31、Flink中的Window出现了数据倾斜，你有什么解决办法？</a></li>
            <li><a href="#32使用keyby算子时某一个key的数据量过大导致数据倾斜怎么处理">32、使用KeyBy算子时，某一个Key的数据量过大，导致数据倾斜，怎么处理？</a></li>
            <li><a href="#33flink在使用聚合函数之后出现数据热点怎么解决">33、Flink在使用聚合函数之后出现数据热点怎么解决</a></li>
            <li><a href="#34flink-任务延迟高想解决这个问题你会如何入手">34、Flink 任务延迟高，想解决这个问题，你会如何入手？</a></li>
            <li><a href="#35flink是如何保证exactly-once语义的">35、Flink是如何保证Exactly-once语义的？</a></li>
            <li><a href="#36说说flink的状态">36、说说Flink的状态</a></li>
            <li><a href="#37说说flink的状态储存机制">37、说说Flink的状态储存机制</a></li>
            <li><a href="#38介绍一下flink的cep机制">38、介绍一下Flink的CEP机制</a></li>
            <li><a href="#39flink-cep-编程中当状态没有到达的时候会将数据保存在哪里">39、Flink CEP 编程中当状态没有到达的时候会将数据保存在哪里？</a></li>
            <li><a href="#40flink的并行度是什么flink的并行度设置是怎么样的">40、Flink的并行度是什么？Flink的并行度设置是怎么样的？</a></li>
            <li><a href="#41说说flink的分区策略">41、说说Flink的分区策略</a></li>
            <li><a href="#42tasksolt是什么">42、TaskSolt是什么？</a></li>
            <li><a href="#43flink的slots和并行度有什么关系">43、Flink的Slots和并行度有什么关系？</a></li>
            <li><a href="#44说说flink的资源调度">44、说说Flink的资源调度</a></li>
            <li><a href="#45flink中有没有重启策略">45、Flink中有没有重启策略？</a></li>
            <li><a href="#46flink假如遇到程序异常重启怎么办">46、Flink假如遇到程序异常重启怎么办？</a></li>
            <li><a href="#47flink-的分布式缓存有什么作用如何使用">47、Flink 的分布式缓存有什么作用？如何使用？</a></li>
            <li><a href="#48说说flink中的广播变量使用广播变量的时候需要注意什么">48、说说Flink中的广播变量，使用广播变量的时候需要注意什么？</a></li>
            <li><a href="#49说说flink-operator-chains">49、说说Flink Operator Chains</a></li>
            <li><a href="#50flink什么情况下才会把operator-chain在一起形成算子链">50、Flink什么情况下才会把Operator chain在一起形成算子链？</a></li>
            <li><a href="#51flink序列化如何实现">51、Flink序列化如何实现</a></li>
            <li><a href="#52flink需要依赖于hadoop吗">52、Flink需要依赖于Hadoop吗？</a></li>
            <li><a href="#53flink组件栈有哪些">53、Flink组件栈有哪些</a></li>
            <li><a href="#54flink支持哪些机器学习和图处理库">54、Flink支持哪些机器学习和图处理库？</a></li>
            <li><a href="#55说说flink-运行时组件">55、说说Flink 运行时组件</a></li>
            <li><a href="#56flink的api可分为哪几层">56、Flink的API可分为哪几层？</a></li>
            <li><a href="#57flink中应用在table-api中的udf有几种">57、Flink中应用在table API中的UDF有几种？</a></li>
            <li><a href="#58说说flink-sql的实现原理">58、说说Flink SQL的实现原理</a></li>
            <li><a href="#59说说flink任务提交流程">59、说说Flink任务提交流程</a></li>
            <li><a href="#60flink-on-yarn常见的提交模式有哪些分别有什么优缺点">60、Flink-On-Yarn常见的提交模式有哪些，分别有什么优缺点？</a></li>
            <li><a href="#61说说flink的执行图">61、说说Flink的执行图</a></li>
            <li><a href="#62说说flink的cbo逻辑执行计划和物理执行计划">62、说说Flink的CBO，逻辑执行计划和物理执行计划</a></li>
            <li><a href="#63什么是flink的全局快照为什么需要全局快照">63、什么是Flink的全局快照？为什么需要全局快照？</a></li>
            <li><a href="#64flink维表关联怎么做">64、Flink维表关联怎么做</a></li>
            <li><a href="#65flink如何海量key去重">65、Flink如何海量key去重</a></li>
            <li><a href="#66说说flink的rpc">66、说说Flink的RPC</a></li>
            <li><a href="#参考">参考</a></li>
          </ol>
        </li>
      </ol>
    </li>
  </ol>
</nav>
        </div>
    </section>

            
        
    </aside>


            <main class="main full-width">
    <article class="has-image main-article">
    <header class="article-header">
        <div class="article-image">
            <a href="/p/flink%E9%9D%A2%E8%AF%95%E4%B8%80%E6%96%87%E9%80%9A/">
                <img src="/p/flink%E9%9D%A2%E8%AF%95%E4%B8%80%E6%96%87%E9%80%9A/leaf-8687801_1280_hu17652351712265803209.jpg"
                        srcset="/p/flink%E9%9D%A2%E8%AF%95%E4%B8%80%E6%96%87%E9%80%9A/leaf-8687801_1280_hu17652351712265803209.jpg 800w, /p/flink%E9%9D%A2%E8%AF%95%E4%B8%80%E6%96%87%E9%80%9A/leaf-8687801_1280_hu16542722768128186168.jpg 1600w"
                        width="800" 
                        height="449" 
                        loading="lazy"
                        alt="Featured image of post Flink面试一文通" />
                
            </a>
        </div>
    

    <div class="article-details">
    
    <header class="article-category">
        
            <a href="/categories/%E9%9D%A2%E8%AF%95%E4%B8%93%E9%A2%98/" style="background-color: #2a9d8f; color: #fff;">
                面试专题
            </a>
        
    </header>
    

    <div class="article-title-wrapper">
        <h2 class="article-title">
            <a href="/p/flink%E9%9D%A2%E8%AF%95%E4%B8%80%E6%96%87%E9%80%9A/">Flink面试一文通</a>
        </h2>
    
        
    </div>

    
    
    
    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">2025-03-12</time>
            </div>
        

        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



                <time class="article-time--reading">
                    阅读时长: 48 分钟
                </time>
            </div>
        
    </footer>
    

    
</div>

</header>

    <section class="article-content">
    
    
    <h2 id="高频">高频
</h2><h2 id="基本">基本
</h2><h3 id="简单介绍一下-flink">简单介绍一下 Flink
</h3><p>Flink 是一个框架和分布式处理引擎，用于对无界和有界数据流进行有状态计算。并且 Flink 提供了数据分布、容错机制以及资源管理等核心功能。Flink提供了诸多高抽象层的API以便用户编写分布式任务：</p>
<ul>
<li><strong>DataSet API</strong> ， 对静态数据进行批处理操作，将静态数据抽象成分布式的数据集，用户可以方便地使用Flink提供的各种操作符对分布式数据集进行处理，支持Java、Scala和Python。</li>
<li><strong>DataStream API</strong> ，对数据流进行流处理操作，将流式的数据抽象成分布式的数据流，用户可以方便地对分布式数据流进行各种操作，支持Java和Scala。</li>
<li><strong>Table API</strong> ，对结构化数据进行查询操作，将结构化数据抽象成关系表，并通过类SQL的DSL对关系表进行各种查询操作，支持Java和Scala。</li>
</ul>
<p>此外，Flink 还针对特定的应用领域提供了领域库，例如： Flink ML，Flink 的机器学习库，提供了机器学习Pipelines API并实现了多种机器学习算法。 Gelly，Flink 的图计算库，提供了图计算的相关API及多种图计算算法实现。</p>
<h3 id="flink的主要特点是什么">Flink的主要特点是什么？
</h3><p>Flink的主要特点包括：</p>
<ul>
<li>流式处理和批处理一体化：Flink既支持流式处理，也支持批处理，可以无缝地在流处理和批处理之间切换。</li>
<li>事件驱动的处理模型：Flink使用事件时间和处理时间的概念，支持基于事件的处理和窗口操作，适用于实时数据处理和分析。</li>
<li>高性能和低延迟：Flink的优化引擎可以实现高吞吐量和低延迟的数据处理，适用于需要快速响应的应用场景。</li>
<li>容错性和可靠性：Flink具有容错机制，可以在节点故障时保证数据处理的正确性和一致性。</li>
<li>灵活的编程模型：Flink支持多种编程模型，包括基于流的API（DataStream API）和基于批的API（DataSet API），并提供了多种编程语言接口。</li>
</ul>
<h3 id="flink的应用场景有哪些">Flink的应用场景有哪些？
</h3><ol>
<li><strong>实时数据处理和分析</strong> ：Flink 可以处理实时数据流，支持实时数据处理和分析，适用于实时监控、实时报表和实时分析等场景。</li>
<li><strong>批处理任务</strong> ：Flink 可以处理有界数据集，支持批处理任务，适用于离线数据处理和大规模数据分析等场景。</li>
<li><strong>基于事件的应用</strong> ：Flink 的事件驱动处理模型适合构建基于事件的应用，如实时推荐系统、欺诈检测和实时预测等场景。</li>
<li><strong>流批一体化应用</strong> ：Flink 的流批一体化特性使得可以将流式和批式处理结合起来，适用于需要实时和离线处理结合的应用场景。</li>
<li><strong>数据挖掘和机器学习</strong> ：Flink 可以处理大规模的数据集，并支持各种数据挖掘和机器学习算法，适用于构建大规模的数据挖掘和机器学习应用。</li>
<li><strong>实时计算和决策</strong> ：Flink 支持实时计算和决策，可以根据实时数据流进行实时决策和行动，适用于需要实时决策和行动的场景，如实时定价、实时广告投放等。</li>
<li><strong>物联网应用</strong> ：Flink 可以处理大规模的实时数据流，适用于处理物联网应用中的实时数据，如智能家居、智能城市、智能交通等场景。</li>
</ol>
<h4 id="4flink编程模型是什么">4、Flink编程模型是什么？
</h4><p>其实就一句话，就是 Source-&gt;Transformation-&gt;Sink</p>
<p>Flink 编程模型是一种用于处理流式数据的编程模型，它包括三个核心概念：Source、Transformation 和 Sink。数据流从 Source 开始，经过多个 Transformation 操作，最终到达 Sink 结束。在这个过程中，数据可以被处理、过滤、转换、聚合等操作，以实现数据的实时处理和分析。</p>
<p>具体来说，Flink 编程模型中，开发者需要首先指定数据的 Source，即数据的来源，可以是文件、网络数据流、数据库等。然后，通过一系列 Transformation 操作对数据进行处理，例如过滤、映射、聚合、窗口等操作。这些 Transformation 操作可以组合使用，以实现复杂的数据处理和分析。最后，将处理后的数据发送到 Sink 端，即数据的去向，可以是文件、网络数据流、数据库等。</p>
<p>Flink 编程模型支持事件时间语义，即数据处理按照事件发生的时间进行排序和处理。同时，Flink 还支持窗口操作、状态管理和事件处理等功能，以实现更复杂的数据处理和分析场景。</p>
<h4 id="5讲一下flink的运行架构flink集群有哪些角色各自有什么作用">5、讲一下Flink的运行架构，Flink集群有哪些角色？各自有什么作用？
</h4><p>Flink程序在运行时主要有TaskManager，JobManager，Client三种角色。当 Flink 集群启动后，⾸先会启动⼀个 JobManger 和⼀个或多个的 TaskManager。由 Client 提交任务给 JobManager，JobManager 再调度任务到各个 TaskManager 去执⾏，然后 TaskManager 将⼼跳和统计信息汇报给 JobManager。TaskManager 之间以流的形式进⾏数据的传输。上述三者均为独⽴的 JVM 进程。</p>
<ul>
<li>JobManager：扮演着集群中的管理者Master的角色，它是整个集群的协调者，负责接收Flink Job，协调检查点，Failover 故障恢复等，同时管理Flink集群中从节点TaskManager。</li>
<li>TaskManager：是实际负责执行计算的Worker，在其上执行Flink Job的一组Task，每个TaskManager负责管理其所在节点上的资源信息，如内存、磁盘、网络，在启动的时候将资源的状态向JobManager汇报。</li>
<li>Client：是Flink程序提交的客户端，当用户提交一个Flink程序时，会首先创建一个Client，该Client首先会对用户提交的Flink程序进行预处理，并提交到Flink集群中处理，所以Client需要从用户提交的Flink程序配置中获取JobManager的地址，并建立到JobManager的连接，将Flink Job提交给JobManager。</li>
</ul>
<h4 id="6flink的集群部署模式有哪些">6、Flink的集群部署模式有哪些？
</h4><p>Flink的集群部署模式包括：</p>
<ul>
<li>单机模式：在单个机器上运行Flink集群，适用于开发和测试环境。</li>
<li>本地模式：在本地的多个线程上模拟Flink集群，适用于开发和调试任务。</li>
<li>分离式部署：将JobManager和TaskManager分别部署在不同的机器上，适用于生产环境和大规模任务的执行。</li>
<li>嵌入式模式：将Flink集成到现有的应用程序中，作为库来使用，适用于需要将流处理能力集成到其他应用中的场景。</li>
</ul>
<h4 id="7你们之前flink集群规模有多大">7、你们之前Flink集群规模有多大？
</h4><h4 id="8说说flink集群优化">8、说说Flink集群优化
</h4><p>Flink 集群优化是提高 Flink 集群性能的关键步骤。</p>
<p>以下是一些 Flink 集群优化的建议：</p>
<ol>
<li>taskmanager.heap.mb 调优：taskmanager.heap.mb 是 Flink 任务管理器堆内存的大小，默认为 1024MB。如果需要更高的内存，可以将其调整为 2048MB 或更高。这可以确保任务管理器有足够的内存来处理数据和执行任务。</li>
<li>调整执行任务的并行度：Flink 任务的并行度可以通过任务属性进行调整。增加并行度可以提高任务的执行速度，但也会增加内存和 CPU 的使用量。因此，需要根据具体情况调整任务的并行度。</li>
<li>优化任务调度：Flink 任务调度可以通过多种方式进行优化。例如，可以调整 taskmanager 的数量和分配策略，以确保任务在不同的 taskmanager 上均匀分配。还可以调整任务的优先级和资源要求，以确保任务能够优先获得所需的资源。</li>
<li>优化网络配置：Flink 集群的网络配置也对性能有很大的影响。例如，可以调整 taskmanager 之间的连接方式，以确保任务数据能够快速传输。还可以调整网络带宽和延迟，以确保任务能够在规定时间内完成。</li>
<li>优化状态管理：Flink 任务的状态管理也是一个重要的优化方面。例如，可以使用 Flink 的状态备份和恢复功能，以确保任务状态能够在集群中的不同节点之间同步。还可以调整状态的持久化方式和位置，以确保状态数据不会丢失。</li>
<li>使用 Flink 的高级优化功能：Flink 还提供了许多高级优化功能，例如代码生成、优化器和迭代算子等。这些功能可以显著提高 Flink 集群的性能，但需要根据具体情况进行调整和使用。</li>
</ol>
<p>总结起来，Flink 集群优化需要综合考虑多个方面，包括内存管理、任务调度、网络配置、状态管理和高级优化功能等。通过调整这些参数和配置，可以显著提高 Flink 集群的性能和效率。</p>
<h4 id="9公司怎么提交的实时任务有多少job-manager">9、公司怎么提交的实时任务，有多少Job Manager？
</h4><h4 id="10flink的并行度了解吗flink的并行度设置是怎样的">10、Flink的并行度了解吗？Flink的并行度设置是怎样的？
</h4><p>Flink 程序由多个任务（Source、Transformation、Sink）组成。任务被分成多个并行实例来执行，每个并行实例处理任务的输入数据的子集。任务的并行实例的数量称之为并行度。</p>
<p>我们在实际生产环境中可以从四个不同层面设置并行度：</p>
<ul>
<li>操作算子层面 (Operator Level)：算子.setParallelism(3),实际算子时设置</li>
<li>执行环境层面 (Execution Environment Level)：构建Flink环境时getExecutionEnvironment.setParallelism(1)设置</li>
<li>客户端层面 (Client Level)：提交flink run -p的时候设置</li>
<li>系统层面 (System Level)：flink客户端的配置yml文件中设置</li>
</ul>
<p>需要注意的 <strong>优先级：算子层面&gt;环境层面&gt;客户端层面&gt;系统层面</strong> （实际业务中通常设置和kafka分区数一样或者kafka分区倍数的并行度）。</p>
<p>Flink 可以设置好几个 level 的 parallelism，其中包括 Operator Level、ExecutionEnvironment Level、Client Level、System Level</p>
<p>在 flink-conf.yaml 中通过parallelism.default 配置项给所有 execution environments 指定系统级的默认parallelism；</p>
<p>在 ExecutionEnvironment 里头可以通过 setParallelism 来给 operators、data sources、data sinks 设置默认的 parallelism；</p>
<p>如果 operators、data sources、datasinks 自己有设置 parallelism 则会覆盖 ExecutionEnvironment 设置的 parallelism。</p>
<h4 id="11flink的checkpoint存在哪里">11、Flink的Checkpoint存在哪里？
</h4><p>Flink 的 Checkpoint 是 Flink 的核心组件之一，它用于记录应用程序在特定时刻的状态，以便在应用程序失败时进行恢复。Checkpoint 通常存储在 Flink 的存储系统中，可以是内存、文件系统或 RocksDB。</p>
<ol>
<li>内存</li>
</ol>
<p>Flink 的内存状态是存储在 Java 内存中的。当应用程序运行时，Flink 会将状态数据存储在内存中，并定期将这些状态数据持久化到外部存储系统中。如果应用程序在运行时出现故障，Flink 可以从内存状态中恢复应用程序的状态。</p>
<ol start="2">
<li>文件系统</li>
</ol>
<p>Flink 也可以将状态数据存储在文件系统中。当应用程序运行时，Flink 会将状态数据写入分布式文件系统，如 HDFS 或 NFS。如果应用程序在运行时出现故障，Flink 可以从文件系统中恢复应用程序的状态。</p>
<ol start="3">
<li>RocksDB</li>
</ol>
<p>Flink 还可以将状态数据存储在 RocksDB 中。RocksDB 是一种高性能、高可靠性的键值存储数据库，它支持高效的数据压缩和快速查找。当应用程序运行时，Flink 会将状态数据写入 RocksDB 数据库，并定期将这些状态数据持久化到外部存储系统中。如果应用程序在运行时出现故障，Flink 可以从 RocksDB 中恢复应用程序的状态。</p>
<p>总之，Flink 的 Checkpoint 可以存储在内存、文件系统或 RocksDB 中，具体存储位置由用户配置决定。Flink 提供了一些 API 来管理 Checkpoint，如 checkpointCoordinator.checkpoint() 方法和 checkpointCoordinator.restoreFromCheckpoint() 方法。使用这些 API，用户可以手动触发 Checkpoint，也可以在应用程序失败时自动恢复状态。</p>
<h4 id="12flink的checkpoint机制对比spark有什么不同和优势">12、Flink的checkpoint机制对比spark有什么不同和优势？
</h4><p>Flink 和 Spark 都是主流的大数据处理框架，它们都支持 Checkpoint 机制以保证实时数据的可靠性和容错性。然而，Flink 和 Spark 的 Checkpoint 机制在实现方式和功能上有一些不同之处。</p>
<ol>
<li>实现方式</li>
</ol>
<p>Flink 的 Checkpoint 机制采用了轻量级的分布式快照技术，实现了每个算子的快照以及流动中的数据的快照。这种快照技术可以快速地保存和恢复状态数据，从而减少了故障恢复的时间。而 Spark 的 Checkpoint 机制主要是针对 Driver 的故障恢复做了数据和元数据的 Checkpoint，没有实现算子的快照。</p>
<ol start="2">
<li>故障恢复</li>
</ol>
<p>Flink 的 Checkpoint 机制可以支持任意节点的故障恢复，包括算子和 Driver。当一个节点出现故障时，Flink 会自动切换到其他可用节点，并从最近的 Checkpoint 开始恢复状态数据。而 Spark 的 Checkpoint 机制只能恢复 Driver 的故障，对于算子的故障则需要重新启动整个应用程序。</p>
<ol start="3">
<li>数据一致性</li>
</ol>
<p>Flink 的 Checkpoint 机制可以保证数据一致性，即同一个 Checkpoint 下的所有算子都处于同一个状态。这是因为 Flink 使用了分布式快照技术，确保每个算子都保存了相同的状态数据。而 Spark 的 Checkpoint 机制并不能保证数据一致性，因为在 Spark 中，每个算子都可能保存了不同的状态数据。</p>
<ol start="4">
<li>性能影响</li>
</ol>
<p>Flink 的 Checkpoint 机制采用了轻量级的分布式快照技术，因此其性能影响相对较小。Spark 的 Checkpoint 机制需要将整个应用程序的状态数据都保存到外部存储系统中，因此其性能影响相对较大。</p>
<p>总的来说，Flink 的 Checkpoint 机制相对于 Spark 的 Checkpoint 机制更为复杂和强大，可以支持任意节点的故障恢复，并保证数据一致性。此外，Flink 的 Checkpoint 机制采用了轻量级的分布式快照技术，因此其性能影响相对较小。这些优势使得 Flink 在实时数据处理方面具有更好的可靠性和容错性。</p>
<h4 id="13flink常用的算子有哪些">13、Flink常用的算子有哪些？
</h4><p>Flink 是一个流处理框架，提供了丰富的算子用于数据的处理和转换。以下是一些常见的算子：</p>
<p>Map 算子：将一个数据流中的每个元素映射成另一个元素。Map 算子是 Flink 中最基本的算子之一，它接受一个映射函数作为参数，该函数将输入数据映射到输出数据。</p>
<p>Filter 算子：将一个数据流中的每个元素映射成多个元素。Filter 算子根据指定的条件过滤掉不符合条件的元素，只输出符合条件的元素。</p>
<p>KeyBy 算子：根据指定的 key 对数据流进行分组。KeyBy 算子将数据流中的元素按照指定的 key 进行分组，并将每个分组中的元素聚合在一起。</p>
<p>Window 窗口算子：对数据流进行窗口操作。Window 算子可以指定窗口的类型、大小和滑动方式等参数，对数据流进行窗口操作，例如滚动窗口、滑动窗口、session 窗口等。</p>
<p>Reduce 算子：对数据流中的元素进行归约操作，将多个元素合并成一个元素。Reduce 算子接受一个聚合函数作为参数，该函数将输入数据聚合成输出数据。</p>
<p>Aggregate 算子：对数据流中的元素进行聚合操作。Aggregate 算子与 Reduce 算子类似，但它可以指定多个聚合函数，同时支持局部聚合和全局聚合。</p>
<p>Join 算子：对数据流中的元素进行连接操作。Join 算子可以指定连接的方式、连接的键和连接的条件等参数，将两个数据流连接在一起。</p>
<p>除了上述算子之外，Flink 还提供了很多其他算子，例如 Union、HashJoin、Sort、Limit 等，以实现更复杂的数据处理和分析场景。</p>
<h4 id="14flink的流式处理如何处理延迟">14、Flink的流式处理如何处理延迟？
</h4><p>Flink的流式处理可以通过以下方式处理延迟：</p>
<p>事件时间处理：Flink支持事件时间处理，可以处理乱序事件，根据事件时间对数据进行排序和处理，从而解决延迟问题。</p>
<p>窗口操作：Flink的窗口操作可以根据事件时间或处理时间对数据流进行划分和处理，可以根据需要设定窗口大小和滑动间隔来控制延迟的处理。</p>
<h4 id="15flink-中对窗口的支持包括哪几种说说他们的使用场景">15、Flink 中对窗口的支持包括哪几种？说说他们的使用场景
</h4><p>Flink支持两种划分窗口的方式，按照time和count，session也是一种时间。</p>
<ul>
<li>Tumbling Time Window（滚动时间窗口）：当达到一定时间后的，进行滑动，可以联想到以前用的诺基亚的滑盖手机，这个其实就是微批。用于处理实时数据流中的时间序列数据，如股票价格走势、实时监测流量等。假如我们需要统计每一分钟中用户购买的商品的总数，需要将用户的行为事件按每一分钟进 行切分，这种切分被成为翻滚时间窗口（Tumbling Time Window）。翻滚窗口能将数据流切分成 不重叠的窗口，每一个事件只能属于一个窗口。</li>
<li>Sliding Time Window（滑动时间窗口）：当达到一定时间后，进行翻滚，可以有重叠。用于处理时间序列数据的近期分析，如近 5 分钟用户购买商品总数等。我们可以每 30 秒计算一次最近一分钟用户购买的商品总数。这种窗口我们称为滑动时间窗 口（Sliding Time Window）。在滑窗中，一个元素可以对应多个窗口。</li>
<li>Tumbling Count Window（滚动计数窗口）：当达到一定条数的时候执行计算，无折叠。用于处理计数型数据，如统计网站访问量、分析用户购买行为等。当我们想要每 100 个用户购买行为事件统计购买总数，那么每当窗口中填满 100 个元素了， 就会对窗口进行计算，这种窗口我们称之为翻滚计数窗口（Tumbling Count Window），上图所 示窗口大小为 3 个。</li>
<li>Sliding Count Window（滑动计数窗口）：当达到一定数量后进行滑动。用于处理计数型数据的实时分析，如实时监测广告点击率、实时统计投票数等。</li>
<li>Session Window（会话窗口）：窗口数据没有固定的大小，根据用户传入的参数进行划分，窗口数据无叠加。用于处理用户交互事件流中的数据，如计算每个用户在活跃期间总共购买的商品数量等。类似于当用户退出的时候，计算这个用户之前的动作。在这种用户交互事件流中，我们首先想到的是将事件聚合到会话窗口中（一段用户持续活跃 的周期），由非活跃的间隙分隔开。如上图所示，就是需要计算每个用户在活跃期间总共购买的 商品数量，如果用户 30 秒没有活动则视为会话断开（假设 raw data stream 是单个用户的购买 行为流）。一般而言，window 是在无限的流上定义了一个有限的元素集合。这个集合可以是基于时间的，元素个数的，时间和个数结合的，会话间隙的，或者是自定义的。Flink 的 DataStream API 提供了简洁的算子来满足常用的窗口操作，同时提供了通用的窗口机制来允许用户自己定义 窗口分配逻辑。</li>
</ul>
<h4 id="16flink支持哪些第三方集成">16、Flink支持哪些第三方集成？
</h4><p>Flink支持与多种第三方工具和框架的集成，包括：</p>
<ul>
<li><strong>Apache Kafka</strong> ：Flink可以与Kafka进行无缝集成，作为数据源和数据接收器。</li>
<li><strong>Apache Hadoop</strong> ：Flink可以与Hadoop集成，可以读取Hadoop文件系统中的数据，也可以将处理结果写入Hadoop文件系统。</li>
<li><strong>Apache Hive</strong> ：Flink可以与Hive集成，可以读取Hive表中的数据进行处理和分析。</li>
<li><strong>Apache HBase</strong> ：Flink可以与HBase集成，可以读取和写入HBase中的数据。</li>
<li><strong>Elasticsearch</strong> ：Flink可以与Elasticsearch进行集成，可以将处理结果写入Elasticsearch进行实时搜索和分析。</li>
</ul>
<h4 id="17flink的source和sink有哪些">17、Flink的source和sink有哪些？
</h4><p>Flink支持多种数据源和数据接收器，包括：</p>
<p>数据源：可以从文件系统、Kafka、消息队列等数据源读取数据，并将其转化为数据流进行处理。</p>
<p>数据接收器：可以将处理结果输出到文件系统、数据库、Kafka等数据接收器中，或者发送给下游处理环节。</p>
<p>Flink内置了一些基本数据源和接收器，它们始终可用。该预定义的数据源包括文件、目录和Socket,并可以加载集合和迭代器的数据。该预定义的数据接收器支持写入文件，输出信息和异常 。</p>
<h4 id="18flink支持哪些批处理操作">18、Flink支持哪些批处理操作？
</h4><p>Flink支持多种批处理操作，包括：</p>
<ul>
<li>Map：对数据集中的每个元素应用指定的函数。</li>
<li>Reduce：对数据集进行归约操作，将数据归约为一个结果。</li>
<li>Filter：根据指定的条件过滤数据集中的元素。</li>
<li>Join：将两个数据集按照指定的键进行连接操作。</li>
<li>GroupBy：根据指定的键对数据集进行分组操作。</li>
</ul>
<h4 id="19flink的流处理和批处理如何切换">19、Flink的流处理和批处理如何切换？
</h4><p>Flink 可以无缝地在流处理和批处理之间切换，这主要归功于其基于事件时间的窗口处理机制和灵活的作业调度策略。Flink 提供了两种作业类型：批处理作业和流处理作业。</p>
<p><strong>1. 批处理作业</strong> ：</p>
<p>批处理作业将数据作为有界数据集进行处理，类似于传统的批处理作业。在批处理模式下，Flink 会将数据按照批次进行划分，然后对每个批次进行离线处理。批处理作业通常用于处理历史数据或者定期生成统计报告等场景。</p>
<p>要运行批处理作业，用户需要将数据作为批量文件上传到 Flink 的分布式文件系统（如 HDFS 或本地文件系统），然后通过 Flink 作业的方式进行处理。在批处理作业中，用户可以指定数据的截止时间（截止时间之前的数据会被处理），以及作业的并发度等参数。</p>
<p><strong>2. 流处理作业</strong> ：</p>
<p>流处理作业将数据作为无界数据流进行处理，实时处理数据并生成实时结果。在流处理模式下，Flink 会实时地接收数据，并将其分配给不同的 Task 以进行处理。流处理作业通常用于实时数据处理、实时分析和实时监控等场景。</p>
<p>要运行流处理作业，用户需要将数据源（如 Kafka、Flume 等）与 Flink 集群配置好，然后通过 Flink 作业的方式进行处理。在流处理作业中，用户可以指定数据处理的时间窗口、触发器等参数，以实现实时数据处理的需求。</p>
<p>在 Flink 中，批处理作业和流处理作业之间的切换可以通过修改作业的配置文件实现。例如，修改 <code>batch.file.path</code> 和 <code>streaming.file.path</code> 参数，以指定批处理作业和流处理作业的输入数据路径。此外，用户还可以通过 Flink Web UI 查看和管理作业的状态，以确保作业的正确运行。</p>
<h4 id="20为什么使用-flink-替代-spark">20、为什么使用 Flink 替代 Spark？
</h4><p>Flink 相对于 Spark 的优势主要体现在以下几个方面：</p>
<ol>
<li>低延迟和高吞吐量：Flink 是基于事件驱动的流式计算框架，能够支持低延迟和高吞吐量的数据处理。Flink 的低延迟特性得益于其基于时间窗口的调度机制，可以支持毫秒级的延迟时间。同时，Flink 的高吞吐量也是其优势之一，能够支持每秒千万级别的数据处理。</li>
<li>对流式数据应用场景更好的支持：Flink 专注于流式数据处理，能够更好地支持流式数据的应用场景，如实时计算、实时监控、实时推荐等。而 Spark 更适合于批量数据的处理，如离线分析、批量报告等。</li>
<li>处理乱序数据的能力：Flink 能够很好地处理乱序数据，可以在数据处理的过程中自动处理数据顺序不一致的问题。而 Spark 在处理乱序数据时需要进行额外的配置和处理。</li>
<li>保证 exactly-once 的状态一致性：Flink 可以保证 exactly-once 的状态一致性，即每个事件都会被处理一次且仅一次。而 Spark 在处理数据时存在重复处理的问题，需要进行额外的优化和配置才能保证状态一致性。</li>
</ol>
<p>综上所述，Flink 相对于 Spark 在低延迟、高吞吐量、流式数据应用场景支持、处理乱序数据和保证状态一致性等方面具有优势，因此被越来越多的公司和开发者所采用。</p>
<h4 id="21说说flink-的容错机制flink是如何做到容错的">21、说说Flink 的容错机制，Flink是如何做到容错的？
</h4><p>Flink 是一个分布式流处理框架，它实现了容错机制以确保在节点故障时，数据不会丢失并且可以进行故障恢复。Flink 的容错机制主要依靠两个强大的机制：Checkpoint 和 State。</p>
<ul>
<li><strong>Checkpoint</strong> ：是一种快照机制，它用于定期备份 Flink 程序中的状态，并将其存储在外部存储系统中。当节点发生故障时，Flink 可以使用 Checkpoint 来恢复程序的状态，并从故障点继续处理数据流。Checkpoint 的备份可以是全量的，也可以是增量的，这取决于 Checkpoint 的触发条件和备份策略。Flink 还支持 Exactly-Once 语义，这意味着在故障恢复时，Flink 可以确保每个事件都被处理了一次且仅一次。</li>
<li><strong>State</strong> ：是 Flink 中的另一种重要机制，它用于存储计算过程中的中间状态。State 可以分为两种类型：Operator State 和 Keyed State。Operator State 是一种基于算子的状态，它存储在算子内部，并随着算子的执行而更新。Keyed State 是一种基于键的状态，它存储在 Stateful Function 内部，并使用键来标识状态的数据。Keyed State 可以具有过期时间（TTL），这使得 Flink 可以在状态过期时自动清理过期的状态数据。</li>
</ul>
<p>在 Flink 中，Checkpoint 和 State 是相互依存的。Checkpoint 用于备份 State，并确保在节点故障时，可以恢复程序的状态。而 State 则用于存储计算过程中的中间状态，并支持 Exactly-Once 语义。Flink 通过这两个机制的结合，实现了强大的容错和故障恢复能力，使得 Flink 在分布式流处理中具有高度的可靠性和可用性。</p>
<h4 id="22flink是如何做到高效的网络数据交换的">22、Flink是如何做到高效的网络数据交换的？
</h4><p>Flink 在网络数据交换方面做到了高效，主要归功于以下几个方面：</p>
<ol>
<li><strong>分布式数据交换</strong> ：Flink 使用了基于 JobGraph 的分布式计算模型，数据可以在不同的 Task 中进行交互。这种分布式数据交换使得 Flink 能够充分利用集群中的多个节点来处理大规模的数据流，从而提高了整个系统的并行度和吞吐量。</li>
<li><strong>TaskManager 负责数据交互</strong> ：在 Flink 中，TaskManager 负责管理 Task 的执行和数据交互。TaskManager 会从缓冲区（Buffer）中收集 Records，然后将其发送到其他 Task 中。这种集中式的数据管理方式可以减少网络连接次数，从而提高了网络吞吐量。</li>
<li><strong>批次封装</strong> ：Flink 中的批次（Batching）机制可以将多个 Records 封装在一起，形成一个批次（Batch）。批次封装可以大大减少网络连接次数，因为在分布式场景中，网络 I/O 是一种稀缺资源。减少网络连接次数可以提高系统的吞吐量和并发度。实际上，在 Kafka 源码剖析中，我们也可以看到 Kafka 采用了类似的记录封装机制来提高吞吐量。</li>
<li><strong>网络拥塞控制</strong> ：Flink 在网络数据交换过程中还采用了拥塞控制机制，以避免网络过载。当某个节点的网络带宽占用过高时，Flink 会通过减少该节点的数据输出速率来缓解网络拥塞，从而确保整个系统的稳定运行。</li>
<li><strong>自适应网络拓扑</strong> ：Flink 支持自适应网络拓扑，它可以根据集群中节点的数量和位置动态地调整数据交换的路由策略。这种自适应网络拓扑可以提高系统的性能和可靠性，因为它能够更好地利用集群中的网络资源。</li>
</ol>
<p>综上所述，Flink 在网络数据交换方面实现了高效，主要通过分布式数据交换、TaskManager 负责数据交互、批次封装、网络拥塞控制和自适应网络拓扑等机制来实现。这些机制使得 Flink 在处理大规模数据流时具有高吞吐量、高并发度和高可靠性。</p>
<h4 id="23flink程序在面对数据高峰期时如何处理">23、Flink程序在面对数据高峰期时如何处理？
</h4><p>当 Flink 程序面对数据高峰期时，一种常用的方法是使用大容量的 Kafka 作为数据源，将数据先放到消息队列中，然后再使用 Flink 进行消费。这种方法可以有效地削峰平谷，减缓数据流量对 Flink 程序的影响，从而提高程序的稳定性和可靠性。</p>
<p>不过，使用 Kafka 作为数据源会影响一点实时性。因为 Kafka 是一个异步的消息队列，数据在队列中需要等待消费者消费，所以会存在一定的延迟。为了解决这个问题，可以采用以下方法：</p>
<ol>
<li>调整 Kafka 的参数，如增大 Kafka 的缓存大小、增加 Kafka 的并发消费者数量等，以提高 Kafka 的吞吐量和处理能力。</li>
<li>优化 Flink 程序的配置，如增大 Flink 的并行度、调整 Flink 的内存配置等，以提高 Flink 的处理能力和吞吐量。</li>
<li>采用 Flink 中的 Stateful Functions 或 Checkpointing 功能，以保持数据的一致性和可靠性。Stateful Functions 可以让 Flink 程序对数据的处理具有状态感知能力，从而更好地处理数据流中的事件。而 Checkpointing 功能可以让 Flink 程序在处理数据时，定期将中间状态持久化到外部存储系统中，以便在程序失败时进行恢复。</li>
</ol>
<p>综上所述，使用 Kafka 作为数据源可以有效地处理数据高峰期，但需要注意 Kafka 和 Flink 的配置优化，以及数据处理的实时性和一致性问题。</p>
<h4 id="24flink分布式快照的原理是什么">24、Flink分布式快照的原理是什么？
</h4><p>Flink的容错机制的核心部分是制作分布式数据流和操作算子状态的一致性快照。 这些快照充当一致性checkpoint，系统可以在发生故障时回滚。 Flink用于制作这些快照的机制在“分布式数据流的轻量级异步快照”中进行了描述。 它受到分布式快照的标准Chandy-Lamport算法的启发，专门针对Flink的执行模型而定制。</p>
<p>barriers在数据流源处被注入并行数据流中。快照n的barriers被插入的位置（我们称之为Sn）是快照所包含的数据在数据源中最大位置。</p>
<p>例如，在Apache Kafka中，此位置将是分区中最后一条记录的偏移量。 将该位置Sn报告给checkpoint协调器（Flink的JobManager）。</p>
<p>然后barriers向下游流动。当一个中间操作算子从其所有输入流中收到快照n的barriers时，它会为快照n发出barriers进入其所有输出流中。</p>
<p>一旦sink操作算子（流式DAG的末端）从其所有输入流接收到barriers n，它就向checkpoint协调器确认快照n完成。</p>
<p>在所有sink确认快照后，意味快照着已完成。一旦完成快照n，job将永远不再向数据源请求Sn之前的记录，因为此时这些记录（及其后续记录）将已经通过整个数据流拓扑，也即是已经被处理结束。</p>
<h4 id="25flink跟spark-streaming的区别">25、Flink跟Spark Streaming的区别
</h4><p>这个问题是一个非常宏观的问题，因为两个框架的不同点非常之多。但是在面试时有非常重要的一点一定要回答出来：Flink 是标准的实时处理引擎，基于事件驱动。而 Spark Streaming 是微批（Micro-Batch）的模型。</p>
<p>下面我们就分几个方面介绍两个框架的主要区别：</p>
<ol>
<li>架构模型Spark Streaming 在运行时的主要角色包括：Master、Worker、Driver、Executor，Flink 在运行时主要包含：Jobmanager、Taskmanager和Slot。</li>
<li>任务调度Spark Streaming 连续不断的生成微小的数据批次，构建有向无环图DAG，Spark Streaming 会依次创建 DStreamGraph、JobGenerator、JobScheduler。Flink 根据用户提交的代码生成 StreamGraph，经过优化生成 JobGraph，然后提交给 JobManager进行处理，JobManager 会根据 JobGraph 生成 ExecutionGraph，ExecutionGraph 是 Flink 调度最核心的数据结构，JobManager 根据 ExecutionGraph 对 Job 进行调度。</li>
<li>时间机制Spark Streaming 支持的时间机制有限，只支持处理时间。 Flink 支持了流处理程序在时间上的三个定义：处理时间、事件时间、注入时间。同时也支持 watermark 机制来处理滞后数据。</li>
<li>容错机制对于 Spark Streaming 任务，我们可以设置 checkpoint，然后假如发生故障并重启，我们可以从上次 checkpoint 之处恢复，但是这个行为只能使得数据不丢失，可能会重复处理，不能做到恰好一次处理语义。Flink 则使用两阶段提交协议来解决这个问题。</li>
</ol>
<h4 id="26说说flink的几种时间语义">26、说说Flink的几种时间语义
</h4><p>Flink 支持三种时间语义：Event Time、Ingestion Time 和 Processing Time。</p>
<p><strong>1. Event Time（事件时间）</strong></p>
<p>Event Time 是事件创建的时间，它通常由事件中的时间戳描述。通常由事件生成器或者传感器生成。在 Flink 中，事件时间可以通过 water-mark 或者定时器来处理。例如，在采集日志数据时，每一条日志都会记录自己的生成时间，Flink 通过时间戳分配器访问事件时间戳。Event Time 是事件产生的时间，与数据处理的时间无关，因此它可以反映事件产生的实时性，但是对于数据处理的延迟和异步性无法体现。</p>
<p><strong>2. Ingestion Time（注入时间）</strong></p>
<p>Ingestion Time 是数据进入 Flink 的时间。它是指数据被 Flink 算子处理的时间，与事件创建的时间无关。Ingestion Time 能够反映数据处理的延迟和异步性，但是无法反映事件产生的实时性。</p>
<p><strong>3. Processing Time（处理时间）</strong></p>
<p>Processing Time 是每一个执行基于时间操作的算子的本地系统时间，与机器相关。它是指算子处理数据的时间，与事件创建的时间和数据进入 Flink 的时间无关。Processing Time 是默认的时间属性，除非明确指定时间语义为 Event Time 或 Ingestion Time。</p>
<p>在实际应用中，选择合适的时间语义可以影响 Flink 处理的数据流的正确性和效率。</p>
<p>例如，如果需要处理实时数据流，那么选择 Event Time 更为合适；</p>
<p>如果需要处理延迟数据流，那么选择 Ingestion Time 更为合适；</p>
<p>如果需要处理离线数据集，那么选择 Processing Time 更为合适。</p>
<p>同时，Flink 也提供了 WaterMark 机制来处理延迟数据和异步数据，以保证数据处理的正确性和可靠性。</p>
<h4 id="27说说flink中的watermark机制">27、说说Flink中的Watermark机制
</h4><p>Flink 中的 Watermark 机制是一种衡量 Event Time 进展的机制，可以用于处理乱序事件。在数据流处理过程中，由于网络延迟、背压等多种因素的影响，数据可能会乱序到达。为了正确处理这些乱序事件，Flink 引入了 Watermark 机制，结合窗口 (Window) 来实现。</p>
<p>Watermark 是一个时间戳，用于表示事件时间小于等于该时间戳的数据都已经到达。在 Flink 中，每个 Operator 都会维护一个当前的 Watermark，当一个事件到达时，如果它的时间戳小于等于当前 Watermark，那么该事件就会被认为是到达了，会被放入窗口中进行处理。窗口的执行是由 Watermark 触发的，当 Watermark 达到窗口的结束时间时，窗口就会触发并执行其中的计算逻辑。</p>
<p>为了实现窗口的正确处理，Flink 还引入了事件时间 (Event Time) 概念，每个事件都会携带一个时间戳，表示该事件产生的时间。在数据流处理过程中，Flink 会根据事件时间戳的顺序来处理事件，这样可以保证事件的正确顺序。但是，由于网络延迟、背压等原因，事件可能会乱序到达，这就需要使用 Watermark 机制来处理这些乱序事件。</p>
<p>总结起来，Flink 中的 Watermark 机制是用于处理乱序事件的一种机制，它可以设定延迟触发，用于表示事件时间小于等于该时间戳的数据都已经到达。通过结合窗口机制，Watermark 机制可以实现对乱序事件的正确处理，保证数据流的正确性和完整性。</p>
<h4 id="28flink怎么做压力测试和监控">28、Flink怎么做压力测试和监控？
</h4><p>产生的数据流的速度如果过快，而下游的算子消费不过来的话，会产生背压。背压的监控可以使用Flink Web UI来可视化监控Metrics，一旦报警就能知道。一般情况下可能由于sink这个操作符没有优化好，做一下优化就可以了。</p>
<p>设置watermark的最大延迟时间这个参数，如果设置的过大，可能会造成内存的压力。可以设置最大延迟时间小一些，然后把迟到的元素发送到测输出流中，晚一点更新结果。</p>
<p>还有就是滑动窗口的长度如果过大，而滑动距离很短的话，Flink的性能也会下降的厉害。可以通过分片的方法，将每个元素只存入一个“重叠窗口”，这样就可以减少窗口处理中状态的写入。</p>
<h4 id="29flink是通过什么机制实现的背压机制">29、Flink是通过什么机制实现的背压机制？
</h4><p>Flink在运行时主要由operators和streams两大构件组成。每个operator会消费中间状态的流，并在流上进行转换，然后生成新的流。对于Flink的网络机制一种形象的类比是，Flink使用了高效有界的分布式阻塞队列，就像Java通过的阻塞队列（BlockingQueue）一样。使用BlockingQueue的话，一个较慢的接受者会降低发送者的发送速率，因为一旦队列满了（有界队列）发送者会被阻塞。</p>
<p>在Flink中，这些分布式阻塞队列就是这些逻辑流，而队列容量通过缓冲池（LocalBufferPool）实现的。每个被生产和消费的流都会被分配一个缓冲池。缓冲池管理者一组缓冲（Buffer），缓冲在被消费后可以被回收循环利用。</p>
<h4 id="30flink是如何处理反压的如何监控和发现">30、Flink是如何处理反压的？如何监控和发现？
</h4><p>Flink 的反压（Backpressure）是指当一个 Operator 的输出速度比其下游 Operator 的输入速度慢时，下游 Operator 可能会积累一定数量的数据，导致处理速度变慢，甚至堵塞。为了解决这个问题，Flink 引入了反压机制，以便及时发现并解决数据处理速度不匹配的问题。</p>
<p>Flink 在处理反压问题时，并没有使用复杂的机制，而是采用了一种简单而高效的方法。Flink 在数据传输过程中使用了分布式阻塞队列，从而有效地解决了反压问题。</p>
<p>在 Flink 中，当一个算子的输出速度比下游算子快时，Flink 会使用分布式阻塞队列来缓存输出数据。这样可以避免上游算子过快地生成数据，导致下游算子无法及时处理，从而形成反压。当下游算子需要数据时，它会从队列中取出数据并进行处理。当队列中的数据达到一定阈值时，上游算子会收到通知，从而减缓数据生成速度。这样一来，Flink 就通过分布式阻塞队列实现了反压的缓解。</p>
<p>另外，Flink 通过每个 TaskManager 和 JobManager 之间的通信来实现反压的缓解。当下游处理任务时间太长时，Flink 会检测到这种情况，并认为这是一个反压信号。此时，Flink 会将这个反压信号传递给上游任务的管理器。</p>
<p>具体来说，Flink 的反压策略主要分为以下几个步骤：</p>
<ol>
<li><strong>任务反压</strong> ：当下游任务的处理速度较慢时，Flink 会检测到这种情况，并认为这是一个反压信号。此时，Flink 会将这个反压信号传递给上游任务的管理器。</li>
<li><strong>调整数据生成速度</strong> ：当上游任务的管理器收到反压信号后，会根据反压信号的强度来调整数据生成速度。通常情况下，反压信号越强，上游任务生成的数据量就会减少，以减轻下游任务的负担。</li>
<li><strong>控制反压</strong> ：Flink 还会通过一些控制机制来避免过度反压。例如，当上游任务的数据生成速度过慢时，Flink 会限制反压的强度，以避免数据积压过多。此外，Flink 还会设置一个反压阈值，当反压信号超过这个阈值时，Flink 会认为任务已经处于一个不稳定的状态，并会采取相应的措施，如调整任务并行度、暂停任务等。</li>
<li><strong>恢复数据生成速度</strong> ：当下游任务的处理速度恢复到正常水平时，Flink 会检测到这个变化，并逐渐增加上游任务的数据生成速度，以恢复数据流。</li>
</ol>
<p>可以根据下游任务的处理速度来动态调整上游任务的数据生成速度，以缓解数据积压问题。这种策略在实际应用中可以提高 Flink 任务的处理效率和稳定性。</p>
<p>Flink 的反压监控和发现主要通过以下方式进行：</p>
<ol>
<li><strong>Flink Web UI</strong> ：Flink Web UI 是一个基于 Web 的用户界面，用于管理和监控 Flink 集群。在 Flink Web UI 中，用户可以查看作业的运行状态、任务管理信息以及反压状态。具体地，在“Jobs”页面中，用户可以查看每个作业的 Backpressure 状态，包括 OK、LOW 和 HIGH 三种状态。此外，在“Task Managers”页面中，用户还可以查看每个 TaskManager 的心跳信息和反压状态。</li>
<li><strong>Flink 命令行工具</strong> ：除了 Web UI 外，用户还可以使用 Flink 提供的命令行工具（如“flink”和“jobmanager”）来进行反压监控。例如，使用“jobmanager”命令，用户可以查看作业的详细信息，包括任务状态和反压状态。</li>
<li><strong>第三方监控工具</strong> ：除了 Flink 自带的监控工具外，还有一些第三方的 Flink 监控工具可以帮助用户监控反压状态。例如，Apache Kafka 提供了一个名为“Kafka Console Consumer”的工具，用于查看 Kafka 主题的消费情况。通过这个工具，用户可以了解数据生产的速度，从而判断是否存在反压问题。</li>
<li><strong>自定义监控与报警</strong> ：为了更加实时和准确地监控反压状态，用户可以编写自定义的监控与报警脚本。这些脚本可以定期获取 Flink 集群的状态信息，并根据预设的规则发送告警通知。例如，当发现某个 Operator 的反压状态为 HIGH 时，可以自动发送告警邮件给相关人员。</li>
</ol>
<p>总之，Flink 通过 Web UI、命令行工具、第三方监控工具以及自定义监控与报警等多种方式，帮助用户实时监控和发现反压问题，从而确保数据处理的高效和稳定。</p>
<h4 id="31flink中的window出现了数据倾斜你有什么解决办法">31、Flink中的Window出现了数据倾斜，你有什么解决办法？
</h4><p>Flink 中的窗口操作是一种基于时间窗口的数据处理方式，可以用于统计分析、监控、实时计算等应用场景。然而，当数据量过大或者数据发送速度不均匀时，可能会导致窗口中堆积的数据量相差过多，即出现了数据倾斜的情况。</p>
<p>数据倾斜会对 Flink 的性能产生负面影响，因为窗口计算需要对所有数据进行聚合操作，而数据倾斜会导致部分窗口的数据量过大，从而增加计算时间和资源消耗。为了解决数据倾斜问题，可以采用以下几种方法：</p>
<ol>
<li><strong>在数据进入窗口之前做预聚合</strong> ：这种方法可以在数据进入窗口之前，先进行一定的聚合操作，使得每个窗口中的数据量相对均匀。具体的做法可以是在数据源处进行预聚合，或者在 Flink 中使用 DataStream API 中的窗口聚合函数（如 Tumbling Windows 和 Sliding Windows）进行预聚合。</li>
<li><strong>重新设计窗口聚合的 key</strong> ：在某些情况下，窗口聚合的 key 可能需要进行重新设计，以避免数据倾斜。例如，可以将 key 设计为数据发送的时间戳，而不是数据本身的某些属性。这样可以使得窗口中的数据量更加均匀，从而避免数据倾斜。</li>
<li><strong>调整窗口参数</strong> ：在某些情况下，可以通过调整窗口参数来避免数据倾斜。例如，可以增加窗口的大小或者增加窗口的滑动间隔，使得窗口中的数据量更加均匀。</li>
<li><strong>使用 Flink 的 Ttl 操作</strong> ：Flink 中的 Ttl 操作可以在数据到达窗口时，根据数据的时间戳进行淘汰操作，从而避免数据倾斜。具体的做法是设置一个 Ttl 时间，当数据到达窗口时，如果数据的时间戳已经超过了 Ttl 时间，则将该数据淘汰，从而避免数据倾斜。</li>
</ol>
<p>综上所述，解决 Flink 中的窗口数据倾斜问题需要根据具体情况进行分析和处理。可以采用预聚合、重新设计窗口聚合的 key、调整窗口参数或者使用 Flink 的 Ttl 操作等方法来避免数据倾斜，从而提高 Flink 的性能和可靠性。</p>
<h4 id="32使用keyby算子时某一个key的数据量过大导致数据倾斜怎么处理">32、使用KeyBy算子时，某一个Key的数据量过大，导致数据倾斜，怎么处理？
</h4><p>当使用 KeyBy 算子时，如果某个 Key 的数据量过大，会导致数据倾斜，影响计算效率。为了解决这个问题，可以考虑以下方法：</p>
<ol>
<li>将 Key 进行散列，将 Key 转换为 Key-随机数的形式，这样可以保证数据散列，对打散后的数据进行聚合统计。这时，我们会得到原始的 Key 加上随机数的统计结果。</li>
<li>将散列的 Key 去除拼接的随机数，得到原始的 Key，然后进行二次 KeyBy 进行结果统计。这样可以保证数据倾斜不会影响最终的结果。</li>
</ol>
<h4 id="33flink在使用聚合函数之后出现数据热点怎么解决">33、Flink在使用聚合函数之后出现数据热点怎么解决
</h4><p>Flink 在使用聚合函数之后出现数据热点的问题，主要是由于某些聚合函数的计算量比较大，导致数据处理速度较慢，从而产生了数据积压和延迟。这种情况下，可以通过以下几种方法来解决数据热点问题：</p>
<ol>
<li><strong>增加计算资源</strong> ：增加计算节点和内存资源，提高 Flink 集群的计算能力，从而加快数据处理速度，降低数据积压和延迟。</li>
<li><strong>调整聚合函数参数</strong> ：有些聚合函数的计算量比较大，可以考虑调整聚合函数的参数，减少计算量，从而提高数据处理速度。例如，可以调整窗口的大小或者滑动间隔等参数。</li>
<li><strong>使用批量处理</strong> ：将数据按照一定的时间间隔进行批量处理，降低实时处理的压力，从而减少数据积压和延迟。例如，可以使用 Flink 的 Batch 操作进行批量处理。</li>
<li><strong>采用数据重复消除策略</strong> ：在某些情况下，数据热点可能是由于某些数据的重复导致的。可以采用数据重复消除策略，例如使用 Flink 中的 Checkpointing 操作，从而避免重复数据导致的数据热点问题。</li>
<li><strong>调整数据源参数</strong> ：在某些情况下，数据源的参数设置可能导致数据热点问题。可以调整数据源的参数，例如发送数据的间隔时间、数据压缩等方式，从而降低数据热点问题。</li>
</ol>
<p>综上所述，解决 Flink 中的数据热点问题需要根据具体情况进行分析和处理。可以采用增加计算资源、调整聚合函数参数、使用批量处理、采用数据重复消除策略或者调整数据源参数等方法来解决数据热点问题，从而提高 Flink 的性能和可靠性。</p>
<h4 id="34flink-任务延迟高想解决这个问题你会如何入手">34、Flink 任务延迟高，想解决这个问题，你会如何入手？
</h4><p>如果 Flink 任务延迟高，需要从以下几个方面入手进行优化：</p>
<ol>
<li><strong>资源调优</strong> ：首先检查 Flink 集群的资源使用情况，如果发现某些节点资源使用率过高，可以考虑增加节点数量或者调整节点的资源配置，如增加内存、CPU 等。此外，还可以调整任务管理器的资源分配策略，如优先使用空闲节点等。</li>
<li><strong>算子调优</strong> ：如果任务延迟高，可以考虑调整算子的参数，如窗口时长、并发数等。窗口时长越短，计算量越大，可能会导致延迟增加，因此需要根据具体情况进行调整。同时，可以考虑使用更高效的算子，如 Reducer 的并行度可以调整为 taskNumber 的因子等。</li>
<li><strong>数据优化</strong> ：数据优化是提高 Flink 任务性能的重要手段。可以考虑使用数据压缩、数据筛选、数据重复消除等技术，以减少数据量和计算量。同时，还可以考虑使用批量处理、Checkpointing 等技术，以优化数据处理流程。</li>
<li><strong>任务调度优化</strong> ：任务调度优化也是提高 Flink 任务性能的重要手段。可以考虑使用 Flink 自带的调度器，如 FairScheduler、DynamicTaskAllocation 等，这些调度器可以根据不同的策略分配任务和管理器。此外，还可以使用自定义的调度器，如基于优先级、基于资源使用情况等调度器，以优化任务调度。</li>
<li><strong>错误处理</strong> ：如果任务出现错误，可能会导致延迟增加。因此，需要设置正确的错误处理策略，如使用 try-catch 语句、设置错误处理延迟等，以避免错误导致的延迟增加。</li>
</ol>
<p>综上所述，要解决 Flink 任务延迟高的问题，需要从资源调优、算子调优、数据优化、任务调度优化和错误处理等方面入手，以提高 Flink 任务的性能和可靠性。</p>
<h4 id="35flink是如何保证exactly-once语义的">35、Flink是如何保证Exactly-once语义的？
</h4><p><strong>如果下级存储支持事务</strong> ：</p>
<p>Flink可以通过实现两阶段提交和状态保存来实现端到端的一致性语义。</p>
<p>分为以下几个步骤：</p>
<ol>
<li>开始事务（beginTransaction）创建一个临时文件夹，来写把数据写入到这个文件夹里面</li>
<li>预提交（preCommit）将内存中缓存的数据写入文件并关闭</li>
<li>正式提交（commit）将之前写完的临时文件放入目标目录下。这代表着最终的数据会有一些延迟</li>
<li>丢弃（abort）丢弃临时文件</li>
<li>若失败发生在预提交成功后，正式提交前。可以根据状态来提交预提交的数据，也可删除预提交的数据。</li>
</ol>
<p><strong>下级存储不支持事务</strong> ：</p>
<p>端到端的exactly-once对sink的要求比较高，具体的实现主要有幂等写入和事务性写入两种方式。幂等写入的场景依赖于业务逻辑，更常见的是用事务性写入。而事务性写入又有预写日志（WAL）和两阶段提交（2PC）两种方式。</p>
<p>如果外部系统不支持事务，那么可以使用预写日志的方式，把结果数据当成状态保存，然后在收到checkpoint完成的通知时，一次性写入sink系统。</p>
<h4 id="36说说flink的状态">36、说说Flink的状态
</h4><p>在 Flink 中，状态是指在实时计算过程中，用于存储和处理数据的一种机制。状态可以分为两种基本类型：KeyedState 和 OperatorState。</p>
<ul>
<li><strong>KeyedState</strong> ：是基于键（Key）的状态，通常和 KeyedStream 的操作相关。KeyedState 包含两种基本的状态：ValueState 和 MapState。ValueState 用于存储单一值的状态，而 MapState 用于存储映射关系。在实际生产中，通常使用 KeyedState 中的 ValueState 和 MapState。</li>
<li><strong>OperatorState</strong> ：是基于算子（Operator）的状态，通常和非 KeyedStream 的操作相关。OperatorState 可以存储算子的内部状态，例如窗口状态、累加器等。</li>
</ul>
<p>KeyedState 和 OperatorState 都是 Flink 中的状态类型，它们在实时计算中起到了重要的作用。KeyedState 通常用于处理基于键的数据，例如对某个键进行计数、聚合等操作；而 OperatorState 通常用于处理非基于键的数据，例如对数据进行窗口操作、排序等操作。</p>
<p>在学习 Flink 中的状态时，需要了解状态的基本概念、分类、使用方式以及状态管理的相关概念。同时，需要掌握如何在程序中使用 KeyedState 和 OperatorState，以便在实时计算中处理数据。</p>
<h4 id="37说说flink的状态储存机制">37、说说Flink的状态储存机制
</h4><p>Flink 的状态储存是指在 Flink 程序运行过程中，用于存储和管理算子状态的数据结构和存储系统。Flink 提供了多种状态后端，以适应不同的应用场景和需求。这里将详细叙述 Flink 的状态储存，包括 1.13 版本之前的状态后端和 1.13 版本之后的状态后端。</p>
<p>1.13 版本之前：</p>
<ul>
<li><strong>MemoryStateBackend</strong> ：开发时使用。这是一种基于内存的状态后端，用于在开发过程中快速调试和测试 Flink 程序。由于它使用内存存储状态数据，因此适用于状态数据较小的场景。</li>
<li><strong>FsStateBackend</strong> ：生产时使用，常用。这是一种基于文件系统的状态后端，将状态数据存储在磁盘上。FsStateBackend 提供了一种高可用性的状态备份和恢复机制，以确保在任务失败时能够恢复状态。</li>
<li><strong>RocksDBStateBackend</strong> ：生产时使用，非常大的状态时用。这是一种基于 RocksDB 的状态后端，使用 RocksDB 数据库存储状态数据。RocksDB 是一种支持高效压缩和快速查找的键值存储系统，适用于处理大规模状态数据的场景。</li>
</ul>
<p>1.13 版本之后：</p>
<ul>
<li><strong>HashMapStateBackend</strong> ：即 MemoryStateBackend 和 FsStateBackend，根据 API 不同。从 1.13 版本开始，Flink 对状态后端进行了整合，将 MemoryStateBackend 和 FsStateBackend 合并为一个统一的 HashMapStateBackend。它使用 HashMap 数据结构存储状态数据，并提供了一些额外的功能，如快照、checkpoint 等。</li>
<li><strong>EmbeddedRocksDBStateBackend</strong> ：生产时使用，非常大的状态时用。这是一种基于 RocksDB 的状态后端，但与 RocksDBStateBackend 不同的是，它将 RocksDB 数据库嵌入到 Flink 的 TaskManager 进程中。这样做的优点是在状态数据较大时，可以减少网络开销和提高访问性能。
总之，Flink 的状态储存系统包括多种状态后端，以适应不同的应用场景和需求。开发者可以根据实际情况选择合适的状态后端，以实现高效、可靠的 Flink 程序。</li>
</ul>
<h4 id="38介绍一下flink的cep机制">38、介绍一下Flink的CEP机制
</h4><p>Flink 的 CEP（Complex Event Processing，复杂事件处理）机制主要用于处理实时数据流中的复杂事件，以便实时地计算和响应这些事件。与传统的批处理方式不同，CEP 机制可以处理实时数据流中的事件，并根据事件的复杂逻辑进行实时计算和响应。</p>
<p>Flink CEP 是在 Flink 中实现的复杂事件处理（CEP）库。CEP 允许在无休止的事件流中检测事件模式，让我们有机会掌握数据中重要的部分。一个或多个由简单事件构成的事件流通过一定的规则匹配，然后输出用户想得到的数据——满足规则的复杂事件。</p>
<p>Flink 的 CEP 机制主要依赖于两个核心组件：Flink 的流处理框架和 CEP 库。Flink 的流处理框架提供了低延迟、高吞吐量的数据流处理能力，可以处理海量的实时数据。而 CEP 库则提供了处理复杂事件的逻辑，可以实现事件的过滤、聚合、路由等功能。通过这两个组件的结合，Flink 能够实现对实时数据流中复杂事件的实时处理和响应。</p>
<p>Flink 的 CEP 机制具有以下特点：</p>
<ol>
<li><strong>实时性</strong> ：Flink 的 CEP 机制可以处理实时数据流中的事件，并实时计算和响应这些事件，具有非常低的延迟。</li>
<li><strong>灵活性</strong> ：CEP 库提供了灵活的事件处理逻辑，可以根据具体的业务需求定义事件的处理方式，例如：过滤、聚合、路由等。</li>
<li><strong>可扩展性</strong> ：Flink 的流处理框架具有优秀的水平扩展能力，可以根据数据流的规模和处理需求动态地增加或减少计算资源。</li>
<li><strong>高可用性</strong> ：Flink 的 CEP 机制支持故障恢复，可以在应用程序出现故障时自动恢复，避免数据丢失和影响。</li>
<li><strong>流式处理</strong> ：Flink 的 CEP 机制采用流式处理的方式处理实时数据流，可以实时地计算和响应事件，不需要先收集所有数据再进行批处理。</li>
</ol>
<p>Flink 的 CEP 机制在实际应用中可以广泛应用于金融、物联网、物流等行业，例如：实时计算股票交易数据、实时监测传感器数据、实时路由物流信息等。了解 Flink 的 CEP 机制有助于更好地应对实时数据流中的复杂事件处理需求。</p>
<h4 id="39flink-cep-编程中当状态没有到达的时候会将数据保存在哪里">39、Flink CEP 编程中当状态没有到达的时候会将数据保存在哪里？
</h4><p>在 Flink CEP 编程中，当状态没有到达的时候，数据通常会被保存在内存中。这是因为在流式处理中，CEP 需要支持 EventTime，也就需要支持数据的迟到现象，这就需要使用 Watermark 机制来处理。对于未匹配成功的事件序列的处理，和迟到数据是类似的。在 Flink CEP 的处理逻辑中，状态没有满足的和迟到的数据，都会存储在一个 Map 数据结构中。</p>
<p>这种内存存储数据的方式在处理延迟数据时是必要的，但也确实可能会对内存造成一定的损伤。为了降低内存占用，可以采取以下策略：</p>
<ol>
<li><strong>合理设置状态的时间间隔</strong> ：根据业务需求和数据处理的实际情况，合理设置状态的时间间隔，以减少内存中存储的数据量。</li>
<li><strong>使用外部状态存储</strong> ：将状态数据存储在外部状态存储中，如 Redis、HBase 等，以减轻内存压力。</li>
<li><strong>优化 CEP 算法</strong> ：对 CEP 算法进行优化，使其在处理延迟数据时能更有效地利用内存，降低内存占用。</li>
<li><strong>合理设置 Flink 的并行度</strong> ：根据实际硬件资源情况和数据处理需求，合理设置 Flink 的并行度，以平衡内存占用和处理速度之间的关系。</li>
</ol>
<p>在 Flink CEP 编程中，当状态没有到达的时候，数据会被保存在内存中。为了降低内存占用，可以采取合理设置状态时间间隔、使用外部状态存储、优化 CEP 算法以及合理设置 Flink 并行度等策略。</p>
<h4 id="40flink的并行度是什么flink的并行度设置是怎么样的">40、Flink的并行度是什么？Flink的并行度设置是怎么样的？
</h4><p>Flink 的并行度是指在执行算子时，可以同时处理的数据流分片的数量。通过设置并行度，可以充分利用集群中的多个 TaskSlots（任务槽）来执行多个数据流分片，从而提高计算性能。并行度这个概念很好理解，例如 Kafka Source，它的并行度默认就是它的分区数量。</p>
<p>Flink 的并行度设置可以通过算子内部的参数或者外部的配置进行调整。</p>
<p>下面是一些常见的设置方法：</p>
<ol>
<li>对于内置算子，如 Map、Filter、Reduce 等，可以通过算子函数的参数来设置并行度。例如，在 Map 算子中，可以使用 <code>map_function.parallelism</code> 参数来设置并行度。</li>
<li>对于自定义算子，可以通过实现 <code>ParallelismAware</code> 接口来设置并行度。在实现该接口的过程中，需要实现 <code>get_parallelism</code> 方法，该方法返回算子的并行度。</li>
<li>在 Flink 的配置文件（如 <code>flink-config.yaml</code>）中，可以设置整个任务的并行度。例如，可以使用 <code>parallelism.task.num</code> 参数来设置 TaskSlots 的数量，从而影响算子的并行度。
一般情况下，我们应该根据数据量来设置并行度。对于源算子（如 Kafka Source、HDFS Source 等），它们的并行度通常可以与分区数量保持一致，因为源算子通常不会产生太多的数据量。对于中间算子（如 Map、Filter 等），并行度可以根据数据量的大小进行适当调整。对于聚合算子（如 Reduce、Aggregate 等）和连接算子（如 Join 等），并行度通常需要根据数据量的大小和算子的压力来综合考虑。</li>
</ol>
<p>合理地设置并行度可以充分发挥 Flink 的并行计算优势，提高数据处理的性能。</p>
<h4 id="41说说flink的分区策略">41、说说Flink的分区策略
</h4><p>Flink 提供了多种分区策略以满足不同数据处理的需求。以下是详细的叙述：</p>
<ol>
<li><strong>GlobalPartitioner</strong> ：将数据发到下游算子的第一个实例。这种分区器适用于数据处理过程中只需要一个实例处理的情况。</li>
<li><strong>ShufflePartitioner</strong> ：将数据随机分发到下游算子。这种分区器适用于数据处理过程中需要对数据进行随机分发的情况，例如数据去重或数据混淆等。</li>
<li><strong>RebalancePartitioner</strong> ：将数据循环发送到下游的实例。这种分区器适用于数据处理过程中需要对数据进行循环处理的情况，例如数据清洗或数据转换等。</li>
<li><strong>RescalePartitioner</strong> ：根据上下游算子的并行度，循环输出到下游算子。这种分区器适用于数据处理过程中需要根据算子的并行度进行数据分配的情况，例如数据聚合或数据过滤等。</li>
<li><strong>BroadcastPartitioner</strong> ：输出到下游算子的每个实例中。这种分区器适用于数据处理过程中需要将数据广播到所有实例中的情况，例如数据源或数据收集等。</li>
<li><strong>ForwardPartitioner</strong> ：上下游算子并行度一样。这种分区器适用于数据处理过程中需要保持上下游算子的并行度一致的情况，例如数据窗口或数据排序等。</li>
<li><strong>KeyGroupStreamPartitioner</strong> ：按 Key 的 Hash 值输出到下游算子。这种分区器适用于数据处理过程中需要根据 Key 的哈希值进行数据分区的情况，例如数据分组或数据汇总等。</li>
<li><strong>KeyedStream</strong> ：根据 keyGroup 索引编号进行分区，会将数据按 Key 的 Hash 值输出到下游算子实例中。该分区器不是提供给用户来用的，而是 Flink 内部使用的。</li>
<li><strong>CustomPartitionerWrapper</strong> ：用户自定义分区器。这种分区器需要用户自己实现 Partitioner 接口，来定义自己的分区逻辑。适用于数据处理过程中需要根据特定逻辑进行数据分区的情况。</li>
</ol>
<p>Flink 提供了多种内置的分区器以满足常见的数据处理需求，同时也支持用户自定义分区器以满足特定需求。</p>
<h4 id="42tasksolt是什么">42、TaskSolt是什么？
</h4><p>TaskSlot 是 Flink 中用于控制 TaskManager 接收任务的数量的一个概念。它是一个抽象的概念，表示一个 TaskManager 能够处理的任务数量。在 Flink 中，TaskManager 是实际执行程序的工作节点，为了起到资源隔离和并行执行的作用，TaskManager 是一个 JVM 进程。通过 TaskSlot 的概念，可以控制 TaskManager 接收的任务数量，从而更好地利用集群资源。</p>
<p>当有一个 source 需要指定三个并行度时，它就需要使用三个 TaskSlot。这是因为 TaskSlot 的数量决定了 TaskManager 能够处理的任务数量。如果 source 需要三个并行度，那么 TaskManager 就需要三个 TaskSlot 来处理这三个并行度的任务。</p>
<p>还有一个需要主要的优化概念是，当算子的并行度相同，并且没有发生并行度改变、或者没有 shuffle 时，这些算子会合并在一起。这样做的目的是为了减少资源的消耗，提高计算效率。</p>
<h4 id="43flink的slots和并行度有什么关系">43、Flink的Slots和并行度有什么关系？
</h4><p>Solt 是 TaskManager 中的概念，表示 TaskManager 的一个槽（Slot）。并行度是程序中的概念，表示程序并行执行的程度。在 Flink 中，Solt 和并行度有着密切的关系。</p>
<p>具体来说，Solt 是 TaskManager 的资源分配单位，它决定了 TaskManager 能够支持的并行度。一个 TaskManager 有多个 Solt，每个 Solt 可以分配给一个 Task，用于执行程序。因此，TaskManager 的并行度就等于其 Solt 的数量。</p>
<p>程序制定的并行度使用的是槽（Solt），也就是说，程序是通过分配 Solt 来控制并行度的。当程序需要更高的并行度时，它可以向 TaskManager 申请更多的 Solt，以便在同一时间内执行更多的 Task。</p>
<p>因此，Solt 和并行度之间的关系可以总结为：Solt 是 TaskManager 中的概念，它决定了 TaskManager 能够支持的并行度；并行度是程序中的概念，它是通过分配 Solt 来控制的。TaskManager 是提供方，提供 Solt 资源给程序使用；程序是使用方，通过分配 Solt 来控制并行度。</p>
<h4 id="44说说flink的资源调度">44、说说Flink的资源调度
</h4><p>Flink 的资源调度是基于 TaskManager 和 Task slot 的概念进行的。TaskManager 是 Flink 中最小的调度单元，负责管理和调度任务。而 Task slot 则是 TaskManager 中最细粒度的资源，代表了一个固定大小的资源子集。每个 TaskManager 会将其所占有的资源平分给它的 slot。通过调整 task slot 的数量，用户可以定义 task 之间是如何相互隔离的。</p>
<p>每个 TaskManager 有一个 slot，也就意味着每个 task 运行在独立的 JVM 中。这样做的好处是，任务之间的隔离更加明确，一个任务出现问题不会影响到其他任务。同时，独立的 JVM 可以提供更好的资源管理和垃圾回收。</p>
<p>而当 TaskManager 拥有多个 slot 时，多个 task 可以运行在同一个 JVM 中。这样做的好处是，可以共享 TCP 连接（基于多路复用）和心跳消息，从而减少数据的网络传输。此外，同一个 JVM 进程中的 task 还可以共享一些数据结构，从而减少每个 task 的消耗。</p>
<p>在 Flink 中，每个 slot 可以接受单个 task，也可以接受多个连续 task 组成的 pipeline。例如，FlatMap 函数占用一个 taskslot，而 key Agg 函数和 sink 函数共用一个 taskslot。这种灵活的资源调度方式可以根据不同的任务需求进行优化和配置，提高系统的资源利用率和性能。</p>
<p>总之，Flink 的资源调度是通过 TaskManager 和 Task slot 的概念来实现的，通过调整 task slot 的数量和分配方式，可以满足不同任务的需求，提高系统的资源利用率和性能。</p>
<p>如下图所示，FlatMap函数占用一个taskslot，而key Agg函数和sink函数共用一个taskslot：</p>
<h4 id="45flink中有没有重启策略">45、Flink中有没有重启策略？
</h4><p>Flink 中的重启策略用于在程序运行过程中发生故障时，如何重新启动算子以恢复程序的运行。重启策略可以在 flink-conf.yaml 中配置，也可以在应用代码中动态指定。</p>
<p>以下是 Flink 中常见的四种重启策略：</p>
<ol>
<li><strong>故障延迟重启策略</strong> （Failure Delay Restart Strategy）：当一个算子失败时，该策略会等待一个固定的时间间隔（即延迟时间）后，重新启动该算子。如果在延迟时间内，同一个算子再次失败，则会重新计算延迟时间，并将其设置为之前的两倍。这个过程会一直重复，直到延迟时间达到一个最大的值（通常是 60 秒），此时 Flink 会放弃重启该算子，并将其标记为永久失败。</li>
<li><strong>故障率重启策略</strong> （Failure Rate Restart Strategy）：该策略基于算子的失败率来决定是否重新启动算子。当一个算子的失败率超过一个预设的阈值时，Flink 会重新启动该算子。这个策略适用于那些可能因为数据异常或程序 BUG 导致频繁失败的算子。</li>
<li><strong>没有重启策略</strong> （No Restart Strategy）：当一个算子失败时，该策略不会重新启动该算子，而是直接跳过该算子，继续执行后面的算子。这个策略适用于那些可以在失败后被忽略的算子，例如那些只是输出数据的算子。</li>
<li><strong>Fallback 重启策略</strong> （Fallback Restart Strategy）：当一个算子失败时，该策略会尝试重新启动该算子，如果重启失败，则会 fallback 到之前的版本，即不会重新启动该算子。这个策略适用于那些可能因为程序升级导致失败的算子，以便在重启失败时能够回滚到之前的版本。</li>
</ol>
<p>如果没有启用 checkpointing，则使用无重启（no restart）策略。如果启用了 checkpointing，但没有配置重启策略，则使用固定间隔（fixed-delay）策略。在固定间隔策略中，Flink 会等待一个固定的时间间隔后，重新启动失败的算子。这个时间间隔可以通过 flink-conf.yaml 中的 restart.delay 配置项来设置。</p>
<h4 id="46flink假如遇到程序异常重启怎么办">46、Flink假如遇到程序异常重启怎么办？
</h4><h4 id="47flink-的分布式缓存有什么作用如何使用">47、Flink 的分布式缓存有什么作用？如何使用？
</h4><h4 id="48说说flink中的广播变量使用广播变量的时候需要注意什么">48、说说Flink中的广播变量，使用广播变量的时候需要注意什么？
</h4><h4 id="49说说flink-operator-chains">49、说说Flink Operator Chains
</h4><h4 id="50flink什么情况下才会把operator-chain在一起形成算子链">50、Flink什么情况下才会把Operator chain在一起形成算子链？
</h4><h4 id="51flink序列化如何实现">51、Flink序列化如何实现
</h4><h4 id="52flink需要依赖于hadoop吗">52、Flink需要依赖于Hadoop吗？
</h4><h4 id="53flink组件栈有哪些">53、Flink组件栈有哪些
</h4><h4 id="54flink支持哪些机器学习和图处理库">54、Flink支持哪些机器学习和图处理库？
</h4><h4 id="55说说flink-运行时组件">55、说说Flink 运行时组件
</h4><h4 id="56flink的api可分为哪几层">56、Flink的API可分为哪几层？
</h4><h4 id="57flink中应用在table-api中的udf有几种">57、Flink中应用在table API中的UDF有几种？
</h4><h4 id="58说说flink-sql的实现原理">58、说说Flink SQL的实现原理
</h4><h4 id="59说说flink任务提交流程">59、说说Flink任务提交流程
</h4><h4 id="60flink-on-yarn常见的提交模式有哪些分别有什么优缺点">60、Flink-On-Yarn常见的提交模式有哪些，分别有什么优缺点？
</h4><h4 id="61说说flink的执行图">61、说说Flink的执行图
</h4><h4 id="62说说flink的cbo逻辑执行计划和物理执行计划">62、说说Flink的CBO，逻辑执行计划和物理执行计划
</h4><h4 id="63什么是flink的全局快照为什么需要全局快照">63、什么是Flink的全局快照？为什么需要全局快照？
</h4><h4 id="64flink维表关联怎么做">64、Flink维表关联怎么做
</h4><h4 id="65flink如何海量key去重">65、Flink如何海量key去重
</h4><h4 id="66说说flink的rpc">66、说说Flink的RPC
</h4><h4 id="参考">参考
</h4><p><a class="link" href="https://www.cnblogs.com/crazymakercircle/p/17619152.html"  target="_blank" rel="noopener"
    >1. 史上最全Flink面试题，高薪必备，大数据面试宝典</a></p>

</section>


    <footer class="article-footer">
    

    </footer>


    
</article>

    

    

<aside class="related-content--wrapper">
    <h2 class="section-title">相关文章</h2>
    <div class="related-content">
        <div class="flex article-list--tile">
            
                
<article class="has-image">
    <a href="/p/hive%E9%9D%A2%E8%AF%95%E4%B8%80%E6%96%87%E9%80%9A/">
        
        
            <div class="article-image">
                <img src="/p/hive%E9%9D%A2%E8%AF%95%E4%B8%80%E6%96%87%E9%80%9A/trees-8136806_1280.357dd549ed51f498bcbf5425f76e0416_hu9173719500181869714.png" 
                        width="250" 
                        height="150" 
                        loading="lazy"
                        alt="Featured image of post Hive面试一文通"
                        
                        data-hash="md5-NX3VSe1R9Ji8v1Ql924EFg==">
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">Hive面试一文通</h2>
        </div>
    </a>
</article>

            
                
<article class="has-image">
    <a href="/p/spark%E9%9D%A2%E8%AF%95%E4%B8%80%E6%96%87%E9%80%9A/">
        
        
            <div class="article-image">
                <img src="/p/spark%E9%9D%A2%E8%AF%95%E4%B8%80%E6%96%87%E9%80%9A/nevada-8338929_1280.7468b0680fbd47334df044231f75c824_hu7977699628175406594.jpg" 
                        width="250" 
                        height="150" 
                        loading="lazy"
                        alt="Featured image of post Spark面试一文通"
                        
                        data-hash="md5-dGiwaA&#43;9RzNN8EQjH3XIJA==">
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">Spark面试一文通</h2>
        </div>
    </a>
</article>

            
                
<article class="has-image">
    <a href="/p/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E4%B8%80%E6%96%87%E9%80%9A/">
        
        
            <div class="article-image">
                <img src="/p/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E4%B8%80%E6%96%87%E9%80%9A/grebe-7972183_1280.6dd8a2d7b8cf99148cf7a877d9459ae8_hu10399000877992530385.jpg" 
                        width="250" 
                        height="150" 
                        loading="lazy"
                        alt="Featured image of post 二叉树遍历一文通"
                        
                        data-hash="md5-bdii17jPmRSM96h32UWa6A==">
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">二叉树遍历一文通</h2>
        </div>
    </a>
</article>

            
                
<article class="has-image">
    <a href="/p/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%80%E6%96%87%E9%80%9A/">
        
        
            <div class="article-image">
                <img src="/p/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%80%E6%96%87%E9%80%9A/matt-le-SJSpo9hQf7s-unsplash.8eae06664ddfb3e8dc6e000756cb703b_hu13612953062116952428.jpg" 
                        width="250" 
                        height="150" 
                        loading="lazy"
                        alt="Featured image of post 动态规划一文通"
                        
                        data-hash="md5-jq4GZk3fs&#43;jcbgAHVstwOw==">
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">动态规划一文通</h2>
        </div>
    </a>
</article>

            
                
<article class="has-image">
    <a href="/p/%E5%8F%8C%E6%8C%87%E9%92%88%E4%B8%80%E6%96%87%E9%80%9A/">
        
        
            <div class="article-image">
                <img src="/p/%E5%8F%8C%E6%8C%87%E9%92%88%E4%B8%80%E6%96%87%E9%80%9A/the-creative-exchange-d2zvqp3fpro-unsplash.60116b1ccfc8632e9a65f7d51df3efc2_hu2042364712198079406.jpg" 
                        width="250" 
                        height="150" 
                        loading="lazy"
                        alt="Featured image of post 双指针一文通"
                        
                        data-hash="md5-YBFrHM/IYy6aZffVHfPvwg==">
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">双指针一文通</h2>
        </div>
    </a>
</article>

            
        </div>
    </div>
</aside>

     
    
        
    <script src="https://utteranc.es/client.js" 
        repo="sherlock-lin/utterances-comments"
        issue-term="pathname"
        
        crossorigin="anonymous"
        async
        >
</script>

<style>
    .utterances {
        max-width: unset;
    }
</style>

<script>
    let utterancesLoaded = false;

    function setUtterancesTheme(theme) {
        let utterances = document.querySelector('.utterances iframe');
        if (utterances) {
            utterances.contentWindow.postMessage(
                {
                    type: 'set-theme',
                    theme: `github-${theme}`
                },
                'https://utteranc.es'
            );
        }
    }

    addEventListener('message', event => {
        if (event.origin !== 'https://utteranc.es') return;

        
        utterancesLoaded = true;
        setUtterancesTheme(document.documentElement.dataset.scheme)
    });

    window.addEventListener('onColorSchemeChange', (e) => {
        if (!utterancesLoaded) return;
        setUtterancesTheme(e.detail)
    })
</script>


    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
            2022 - 
        
        2025 sherlock-lin
    </section>
    
    <section class="powerby">
        使用 <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> 构建 <br />
        主题 <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="3.27.0">Stack</a></b> 由 <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a> 设计
    </section>
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_pv">本站总访问量 <span id="busuanzi_value_site_pv"></span> 次 · </span>
<span id="busuanzi_container_site_uv">您是本站第 <span id="busuanzi_value_site_uv"></span> 位访问者</span>
</footer>


    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css"crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css"crossorigin="anonymous"
            >

            </main>
        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js"integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z&#43;KMkF24hUW8WePSA9HM="crossorigin="anonymous"
                
                >
            </script><script type="text/javascript" src="/ts/main.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>

    </body>
</html>
