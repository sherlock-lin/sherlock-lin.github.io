<!DOCTYPE html>
<html lang="zh-cn" dir="ltr">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content="概述 首先，我们的性能对比测试是以案例为粒度的，也就是常说的Case By Case。然后，在每一个案例中，我们都有对比基准（Baseline）。对比基准的含义是，在不采取任何调优方法的情况下，直接把代码交付执行得到的运行时间。之后，对于每一个案例，我们会采取一种或多种调优方法做性能优化，每一种调优方法都有与之对应的运行时间。最终，我们将不同调优方法的运行时间与对比基准做横向比较，来观察调优前后的性能差异，并分析性能提升/下降的背后原因。\n">
<title>手把手带你提升应用的执行性能</title>

<link rel='canonical' href='https://sherlock-lin.github.io/p/%E6%89%8B%E6%8A%8A%E6%89%8B%E5%B8%A6%E4%BD%A0%E6%8F%90%E5%8D%87%E5%BA%94%E7%94%A8%E7%9A%84%E6%89%A7%E8%A1%8C%E6%80%A7%E8%83%BD/'>

<link rel="stylesheet" href="/scss/style.min.663803bebe609202d5b39d848f2d7c2dc8b598a2d879efa079fa88893d29c49c.css"><meta property='og:title' content="手把手带你提升应用的执行性能">
<meta property='og:description' content="概述 首先，我们的性能对比测试是以案例为粒度的，也就是常说的Case By Case。然后，在每一个案例中，我们都有对比基准（Baseline）。对比基准的含义是，在不采取任何调优方法的情况下，直接把代码交付执行得到的运行时间。之后，对于每一个案例，我们会采取一种或多种调优方法做性能优化，每一种调优方法都有与之对应的运行时间。最终，我们将不同调优方法的运行时间与对比基准做横向比较，来观察调优前后的性能差异，并分析性能提升/下降的背后原因。\n">
<meta property='og:url' content='https://sherlock-lin.github.io/p/%E6%89%8B%E6%8A%8A%E6%89%8B%E5%B8%A6%E4%BD%A0%E6%8F%90%E5%8D%87%E5%BA%94%E7%94%A8%E7%9A%84%E6%89%A7%E8%A1%8C%E6%80%A7%E8%83%BD/'>
<meta property='og:site_name' content='夏洛克-林'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:published_time' content='2025-04-13T10:03:32&#43;08:00'/><meta property='article:modified_time' content='2025-04-13T10:03:32&#43;08:00'/><meta property='og:image' content='https://sherlock-lin.github.io/p/%E6%89%8B%E6%8A%8A%E6%89%8B%E5%B8%A6%E4%BD%A0%E6%8F%90%E5%8D%87%E5%BA%94%E7%94%A8%E7%9A%84%E6%89%A7%E8%A1%8C%E6%80%A7%E8%83%BD/image-20250413100248830-4509770.png' />
<meta name="twitter:title" content="手把手带你提升应用的执行性能">
<meta name="twitter:description" content="概述 首先，我们的性能对比测试是以案例为粒度的，也就是常说的Case By Case。然后，在每一个案例中，我们都有对比基准（Baseline）。对比基准的含义是，在不采取任何调优方法的情况下，直接把代码交付执行得到的运行时间。之后，对于每一个案例，我们会采取一种或多种调优方法做性能优化，每一种调优方法都有与之对应的运行时间。最终，我们将不同调优方法的运行时间与对比基准做横向比较，来观察调优前后的性能差异，并分析性能提升/下降的背后原因。\n"><meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content='https://sherlock-lin.github.io/p/%E6%89%8B%E6%8A%8A%E6%89%8B%E5%B8%A6%E4%BD%A0%E6%8F%90%E5%8D%87%E5%BA%94%E7%94%A8%E7%9A%84%E6%89%A7%E8%A1%8C%E6%80%A7%E8%83%BD/image-20250413100248830-4509770.png' />
    </head>
    <body class="
    article-page
    ">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky ">
    <button class="hamburger hamburger--spin" type="button" id="toggle-menu" aria-label="切换菜单">
        <span class="hamburger-box">
            <span class="hamburger-inner"></span>
        </span>
    </button>

    <header>
        
            
            <figure class="site-avatar">
                <a href="/">
                
                    
                    
                    
                        
                        <img src="/img/cs_hu10005534405353342465.jpg" width="300"
                            height="294" class="site-logo" loading="lazy" alt="Avatar">
                    
                
                </a>
                
                    <span class="emoji">🥳</span>
                
            </figure>
            
        
        
        <div class="site-meta">
            <h1 class="site-name"><a href="/">夏洛克-林</a></h1>
            <h2 class="site-description">欢迎来到一个读书狂魔、偏执狂的博客~</h2>
        </div>
    </header><ol class="menu-social">
            
                <li>
                    <a 
                        href='https://github.com/CaiJimmy/hugo-theme-stack'
                        target="_blank"
                        title="GitHub"
                        rel="me"
                    >
                        
                        
                            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M9 19c-4.3 1.4 -4.3 -2.5 -6 -3m12 5v-3.5c0 -1 .1 -1.4 -.5 -2c2.8 -.3 5.5 -1.4 5.5 -6a4.6 4.6 0 0 0 -1.3 -3.2a4.2 4.2 0 0 0 -.1 -3.2s-1.1 -.3 -3.5 1.3a12.3 12.3 0 0 0 -6.2 0c-2.4 -1.6 -3.5 -1.3 -3.5 -1.3a4.2 4.2 0 0 0 -.1 3.2a4.6 4.6 0 0 0 -1.3 3.2c0 4.6 2.7 5.7 5.5 6c-.6 .6 -.6 1.2 -.5 2v3.5" />
</svg>



                        
                    </a>
                </li>
            
                <li>
                    <a 
                        href='https://twitter.com'
                        target="_blank"
                        title="Twitter"
                        rel="me"
                    >
                        
                        
                            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-twitter" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M22 4.01c-1 .49 -1.98 .689 -3 .99c-1.121 -1.265 -2.783 -1.335 -4.38 -.737s-2.643 2.06 -2.62 3.737v1c-3.245 .083 -6.135 -1.395 -8 -4c0 0 -4.182 7.433 4 11c-1.872 1.247 -3.739 2.088 -6 2c3.308 1.803 6.913 2.423 10.034 1.517c3.58 -1.04 6.522 -3.723 7.651 -7.742a13.84 13.84 0 0 0 .497 -3.753c-.002 -.249 1.51 -2.772 1.818 -4.013z" />
</svg>



                        
                    </a>
                </li>
            
        </ol><ol class="menu" id="main-menu">
        
        
        
        <li >
            <a href='/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="5 12 3 12 12 3 21 12 19 12" />
  <path d="M5 12v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-7" />
  <path d="M9 21v-6a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v6" />
</svg>



                
                <span>主页</span>
            </a>
        </li>
        
        
        <li >
            <a href='/%E5%85%B3%E4%BA%8E/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="7" r="4" />
  <path d="M6 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2" />
</svg>



                
                <span>关于</span>
            </a>
        </li>
        
        
        <li >
            <a href='/archives/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <rect x="3" y="4" width="18" height="4" rx="2" />
  <path d="M5 8v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-10" />
  <line x1="10" y1="12" x2="14" y2="12" />
</svg>



                
                <span>归档</span>
            </a>
        </li>
        
        
        <li >
            <a href='/search/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="10" cy="10" r="7" />
  <line x1="21" y1="21" x2="15" y2="15" />
</svg>



                
                <span>搜索</span>
            </a>
        </li>
        
        
        <li >
            <a href='/%E5%8F%8B%E6%83%85%E9%93%BE%E6%8E%A5/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M10 14a3.5 3.5 0 0 0 5 0l4 -4a3.5 3.5 0 0 0 -5 -5l-.5 .5" />
  <path d="M14 10a3.5 3.5 0 0 0 -5 0l-4 4a3.5 3.5 0 0 0 5 5l.5 -.5" />
</svg>



                
                <span>友情链接</span>
            </a>
        </li>
        
        <li class="menu-bottom-section">
            <ol class="menu">

                
                    <li id="dark-mode-toggle">
                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="8" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="16" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <span>暗色模式</span>
                    </li>
                
            </ol>
        </li>
    </ol>
</aside>

    <aside class="sidebar right-sidebar sticky">
        
            
                
    <section class="widget archives">
        <div class="widget-icon">
            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <line x1="5" y1="9" x2="19" y2="9" />
  <line x1="5" y1="15" x2="19" y2="15" />
  <line x1="11" y1="4" x2="7" y2="20" />
  <line x1="17" y1="4" x2="13" y2="20" />
</svg>



        </div>
        <h2 class="widget-title section-title">目录</h2>
        
        <div class="widget--toc">
            <nav id="TableOfContents">
  <ol>
    <li><a href="#概述">概述</a></li>
    <li><a href="#运行环境">运行环境</a></li>
    <li><a href="#案例1的性能调优人数统计">案例1的性能调优：人数统计</a></li>
    <li><a href="#案例2的性能调优摇号次数分布">案例2的性能调优：摇号次数分布</a>
      <ol>
        <li><a href="#场景1参与摇号的申请者">场景1：参与摇号的申请者</a>
          <ol>
            <li><a href="#思路1shuffle常规优化">思路1：Shuffle常规优化</a></li>
            <li><a href="#思路2数据分区合并">思路2：数据分区合并</a></li>
            <li><a href="#思路3加cache">思路3：加Cache</a></li>
          </ol>
        </li>
        <li><a href="#场景2幸运的中签者">场景2：幸运的中签者</a></li>
      </ol>
    </li>
    <li><a href="#案例3的性能调优中签率的变化趋势">案例3的性能调优：中签率的变化趋势</a></li>
    <li><a href="#案例4的性能调优中签率局部洞察">案例4的性能调优：中签率局部洞察</a></li>
    <li><a href="#案例5的性能调优倍率分析">案例5的性能调优：倍率分析</a></li>
    <li><a href="#总结">总结</a></li>
  </ol>
</nav>
        </div>
    </section>

            
        
    </aside>


            <main class="main full-width">
    <article class="has-image main-article">
    <header class="article-header">
        <div class="article-image">
            <a href="/p/%E6%89%8B%E6%8A%8A%E6%89%8B%E5%B8%A6%E4%BD%A0%E6%8F%90%E5%8D%87%E5%BA%94%E7%94%A8%E7%9A%84%E6%89%A7%E8%A1%8C%E6%80%A7%E8%83%BD/">
                <img src="/p/%E6%89%8B%E6%8A%8A%E6%89%8B%E5%B8%A6%E4%BD%A0%E6%8F%90%E5%8D%87%E5%BA%94%E7%94%A8%E7%9A%84%E6%89%A7%E8%A1%8C%E6%80%A7%E8%83%BD/image-20250413100248830-4509770_hu8111209649381182372.png"
                        srcset="/p/%E6%89%8B%E6%8A%8A%E6%89%8B%E5%B8%A6%E4%BD%A0%E6%8F%90%E5%8D%87%E5%BA%94%E7%94%A8%E7%9A%84%E6%89%A7%E8%A1%8C%E6%80%A7%E8%83%BD/image-20250413100248830-4509770_hu8111209649381182372.png 800w, /p/%E6%89%8B%E6%8A%8A%E6%89%8B%E5%B8%A6%E4%BD%A0%E6%8F%90%E5%8D%87%E5%BA%94%E7%94%A8%E7%9A%84%E6%89%A7%E8%A1%8C%E6%80%A7%E8%83%BD/image-20250413100248830-4509770_hu12029128755062440849.png 1600w"
                        width="800" 
                        height="140" 
                        loading="lazy"
                        alt="Featured image of post 手把手带你提升应用的执行性能" />
                
            </a>
        </div>
    

    <div class="article-details">
    
    <header class="article-category">
        
            <a href="/categories/spark/" style="background-color: #2a9d8f; color: #fff;">
                Spark
            </a>
        
            <a href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/" style="background-color: #2a9d8f; color: #fff;">
                大数据
            </a>
        
    </header>
    

    <div class="article-title-wrapper">
        <h2 class="article-title">
            <a href="/p/%E6%89%8B%E6%8A%8A%E6%89%8B%E5%B8%A6%E4%BD%A0%E6%8F%90%E5%8D%87%E5%BA%94%E7%94%A8%E7%9A%84%E6%89%A7%E8%A1%8C%E6%80%A7%E8%83%BD/">手把手带你提升应用的执行性能</a>
        </h2>
    
        
    </div>

    
    
    
    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">2025-04-13</time>
            </div>
        

        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



                <time class="article-time--reading">
                    阅读时长: 18 分钟
                </time>
            </div>
        
    </footer>
    

    
</div>

</header>

    <section class="article-content">
    
    
    <h2 id="概述">概述
</h2><p>首先，我们的性能对比测试是以案例为粒度的，也就是常说的Case By Case。然后，在每一个案例中，我们都有对比基准（Baseline）。对比基准的含义是，在不采取任何调优方法的情况下，直接把代码交付执行得到的运行时间。之后，对于每一个案例，我们会采取一种或多种调优方法做性能优化，每一种调优方法都有与之对应的运行时间。最终，我们将不同调优方法的运行时间与对比基准做横向比较，来观察调优前后的性能差异，并分析性能提升/下降的背后原因。</p>
<h2 id="运行环境">运行环境
</h2><p>既然调优效果主要由执行时间来体现，那在开始调优之前，我们有必要先来交代一下性能测试采用的硬件资源和配置项设置。硬件资源如下表所示。</p>
<p><img src="/p/%E6%89%8B%E6%8A%8A%E6%89%8B%E5%B8%A6%E4%BD%A0%E6%8F%90%E5%8D%87%E5%BA%94%E7%94%A8%E7%9A%84%E6%89%A7%E8%A1%8C%E6%80%A7%E8%83%BD/image-20250413093812370-4508294.png"
	width="1576"
	height="654"
	srcset="/p/%E6%89%8B%E6%8A%8A%E6%89%8B%E5%B8%A6%E4%BD%A0%E6%8F%90%E5%8D%87%E5%BA%94%E7%94%A8%E7%9A%84%E6%89%A7%E8%A1%8C%E6%80%A7%E8%83%BD/image-20250413093812370-4508294_hu5883318359604148002.png 480w, /p/%E6%89%8B%E6%8A%8A%E6%89%8B%E5%B8%A6%E4%BD%A0%E6%8F%90%E5%8D%87%E5%BA%94%E7%94%A8%E7%9A%84%E6%89%A7%E8%A1%8C%E6%80%A7%E8%83%BD/image-20250413093812370-4508294_hu11163816695912996630.png 1024w"
	loading="lazy"
	
		alt="image-20250413093812370"
	
	
		class="gallery-image" 
		data-flex-grow="240"
		data-flex-basis="578px"
	
></p>
<p>为了避免因为实验本身而等待太长的时间，我使用了比较强悍的机器资源。实际上，为了跑通应用，完成性能对比测试，你使用笔记本也可以。而且为了给后续调优留出足够空间，除了必需的运行资源设置以外，其他配置项全部保留了默认值，具体的资源配置如下表所示。</p>
<p><img src="/p/%E6%89%8B%E6%8A%8A%E6%89%8B%E5%B8%A6%E4%BD%A0%E6%8F%90%E5%8D%87%E5%BA%94%E7%94%A8%E7%9A%84%E6%89%A7%E8%A1%8C%E6%80%A7%E8%83%BD/image-20250413093832407-4508315.png"
	width="1592"
	height="346"
	srcset="/p/%E6%89%8B%E6%8A%8A%E6%89%8B%E5%B8%A6%E4%BD%A0%E6%8F%90%E5%8D%87%E5%BA%94%E7%94%A8%E7%9A%84%E6%89%A7%E8%A1%8C%E6%80%A7%E8%83%BD/image-20250413093832407-4508315_hu16134904733307872087.png 480w, /p/%E6%89%8B%E6%8A%8A%E6%89%8B%E5%B8%A6%E4%BD%A0%E6%8F%90%E5%8D%87%E5%BA%94%E7%94%A8%E7%9A%84%E6%89%A7%E8%A1%8C%E6%80%A7%E8%83%BD/image-20250413093832407-4508315_hu7463283643252428806.png 1024w"
	loading="lazy"
	
		alt="image-20250413093832407"
	
	
		class="gallery-image" 
		data-flex-grow="460"
		data-flex-basis="1104px"
	
></p>
<p>另外，由于调优方法中涉及AQE和DPP这些Spark 3.0新特性，因此，我建议你使用3.0及以上的Spark版本来部署运行环境，我这边采用的版本号是Spark 3.1.1。</p>
<p>接下来，我们就Case By Case地去回顾代码实现，分别分析5个案例的优化空间、可能的调优方法、方法的效果，以及它们与对比基准的性能差异。</p>
<h2 id="案例1的性能调优人数统计">案例1的性能调优：人数统计
</h2><p>首先，我们先来回顾案例1。案例1的意图是统计摇号总人次、中签者人数，以及去掉倍率影响之后的摇号总人次，代码如下所示。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">val</span> <span class="n">rootPath</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="k">_</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1">// 申请者数据（因为倍率的原因，每一期，同一个人，可能有多个号码）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">val</span> <span class="n">hdfs_path_apply</span> <span class="k">=</span> <span class="s">s&#34;</span><span class="si">${</span><span class="n">rootPath</span><span class="si">}</span><span class="s">/apply&#34;</span>
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">applyNumbersDF</span> <span class="k">=</span> <span class="n">spark</span><span class="o">.</span><span class="n">read</span><span class="o">.</span><span class="n">parquet</span><span class="o">(</span><span class="n">hdfs_path_apply</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="n">applyNumbersDF</span><span class="o">.</span><span class="n">count</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 中签者数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">val</span> <span class="n">hdfs_path_lucky</span> <span class="k">=</span> <span class="s">s&#34;</span><span class="si">${</span><span class="n">rootPath</span><span class="si">}</span><span class="s">/lucky&#34;</span>
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">luckyDogsDF</span> <span class="k">=</span> <span class="n">spark</span><span class="o">.</span><span class="n">read</span><span class="o">.</span><span class="n">parquet</span><span class="o">(</span><span class="n">hdfs_path_lucky</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="n">luckyDogsDF</span><span class="o">.</span><span class="n">count</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1">// 申请者数据（去掉倍率的影响）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">val</span> <span class="n">applyDistinctDF</span> <span class="k">=</span> <span class="n">applyNumbersDF</span><span class="o">.</span><span class="n">select</span><span class="o">(</span><span class="s">&#34;batchNum&#34;</span><span class="o">,</span> <span class="s">&#34;carNum&#34;</span><span class="o">).</span><span class="n">distinct</span>
</span></span><span class="line"><span class="cl"><span class="n">applyDistinctDF</span><span class="o">.</span><span class="n">count</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>从上面的代码实现中，我们不难发现，短短的几行代码共有3个Actions，也就是3个不同数据集上的count操作，这3个Actions会触发3个Spark Jobs。其中，前2个Jobs都是读取数据源之后立即计数，没什么优化空间。第3个Job是在applyNumbersDF之上做去重，然后再统计计数。结合上一讲对于不同案例的讲解，我们知道，applyNumbersDF、luckyDogsDF和applyDistinctDF这3个数据集，在后续的案例中会被反复引用。</p>
<p>因为上述3个数据集的引用次数过于频繁，所以我们甚至都不用去计算“运行成本占比”，就可以判定：利用Cache一定有利于提升执行性能。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">使用Cache的一般性原则：- 如果RDD/DataFrame/Dataset在应用中的引用次数为1，那么坚决不使用Cache- 如果引用次数大于1，且运行成本占比超过30<span class="c">%，应当考虑启用Cache
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>因此，对于第3个Job，我们可以利用Cache机制来提升执行性能。调优方法很简单，我们只需在applyNumbersDF.count之前添加一行代码：applyNumbersDF.cache。</p>
<p>由于这个案例中性能对比测试的关注点是第3个Job，那为了方便横向对比，我们先把不相干的Jobs和代码去掉，整理之后的对比基准和调优代码如下表所示。</p>
<p><img src="/p/%E6%89%8B%E6%8A%8A%E6%89%8B%E5%B8%A6%E4%BD%A0%E6%8F%90%E5%8D%87%E5%BA%94%E7%94%A8%E7%9A%84%E6%89%A7%E8%A1%8C%E6%80%A7%E8%83%BD/image-20250413094623281-4508784.png"
	width="1610"
	height="798"
	srcset="/p/%E6%89%8B%E6%8A%8A%E6%89%8B%E5%B8%A6%E4%BD%A0%E6%8F%90%E5%8D%87%E5%BA%94%E7%94%A8%E7%9A%84%E6%89%A7%E8%A1%8C%E6%80%A7%E8%83%BD/image-20250413094623281-4508784_hu16367134057214566181.png 480w, /p/%E6%89%8B%E6%8A%8A%E6%89%8B%E5%B8%A6%E4%BD%A0%E6%8F%90%E5%8D%87%E5%BA%94%E7%94%A8%E7%9A%84%E6%89%A7%E8%A1%8C%E6%80%A7%E8%83%BD/image-20250413094623281-4508784_hu7243887854153168829.png 1024w"
	loading="lazy"
	
		alt="image-20250413094623281"
	
	
		class="gallery-image" 
		data-flex-grow="201"
		data-flex-basis="484px"
	
></p>
<p>然后，我们把这两份代码分别打包、部署和执行，并记录applyDistinctDF.count作业的执行时间，来完成性能对比测试，我把执行结果记录到了下面的表格中。</p>
<p><img src="/p/%E6%89%8B%E6%8A%8A%E6%89%8B%E5%B8%A6%E4%BD%A0%E6%8F%90%E5%8D%87%E5%BA%94%E7%94%A8%E7%9A%84%E6%89%A7%E8%A1%8C%E6%80%A7%E8%83%BD/image-20250413094648191.png"
	width="1608"
	height="538"
	srcset="/p/%E6%89%8B%E6%8A%8A%E6%89%8B%E5%B8%A6%E4%BD%A0%E6%8F%90%E5%8D%87%E5%BA%94%E7%94%A8%E7%9A%84%E6%89%A7%E8%A1%8C%E6%80%A7%E8%83%BD/image-20250413094648191_hu6662256585016452204.png 480w, /p/%E6%89%8B%E6%8A%8A%E6%89%8B%E5%B8%A6%E4%BD%A0%E6%8F%90%E5%8D%87%E5%BA%94%E7%94%A8%E7%9A%84%E6%89%A7%E8%A1%8C%E6%80%A7%E8%83%BD/image-20250413094648191_hu11070948439828009738.png 1024w"
	loading="lazy"
	
		alt="image-20250413094648191"
	
	
		class="gallery-image" 
		data-flex-grow="298"
		data-flex-basis="717px"
	
></p>
<p>从中我们可以看到，相较于对比基准，调优之后的执行性能提升了20%。坦白地说，这样的提升是我们意料之中的。毕竟前者消耗的是磁盘I/O，而调优之后计数作业直接从内存获取数据。</p>
<h2 id="案例2的性能调优摇号次数分布">案例2的性能调优：摇号次数分布
</h2><p>接下来，我们再来分析案例2。案例2分为两个场景，第一个场景用于统计申请者摇号批次数量的分布情况，第二个场景也是类似，不过它的出发点是中签者，主要用来解答“中签者通常需要摇多少次号才能中签”这类问题。</p>
<h3 id="场景1参与摇号的申请者">场景1：参与摇号的申请者
</h3><p>我们先来回顾一下场景1的代码实现。仔细研读代码，我们不难发现，场景1是典型的单表Shuffle，而且是两次Shuffle。第一次Shuffle操作是以数据列“carNum”为基准做分组计数，第二次Shuffle是按照“x_axis”列再次做分组计数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">val</span> <span class="n">result02_01</span> <span class="k">=</span> <span class="n">applyDistinctDF</span>
</span></span><span class="line"><span class="cl"><span class="o">.</span><span class="n">groupBy</span><span class="o">(</span><span class="n">col</span><span class="o">(</span><span class="s">&#34;carNum&#34;</span><span class="o">))</span>
</span></span><span class="line"><span class="cl"><span class="o">.</span><span class="n">agg</span><span class="o">(</span><span class="n">count</span><span class="o">(</span><span class="n">lit</span><span class="o">(</span><span class="mi">1</span><span class="o">)).</span><span class="n">alias</span><span class="o">(</span><span class="s">&#34;x_axis&#34;</span><span class="o">))</span>
</span></span><span class="line"><span class="cl"><span class="o">.</span><span class="n">groupBy</span><span class="o">(</span><span class="n">col</span><span class="o">(</span><span class="s">&#34;x_axis&#34;</span><span class="o">))</span>
</span></span><span class="line"><span class="cl"><span class="o">.</span><span class="n">agg</span><span class="o">(</span><span class="n">count</span><span class="o">(</span><span class="n">lit</span><span class="o">(</span><span class="mi">1</span><span class="o">)).</span><span class="n">alias</span><span class="o">(</span><span class="s">&#34;y_axis&#34;</span><span class="o">))</span>
</span></span><span class="line"><span class="cl"><span class="o">.</span><span class="n">orderBy</span><span class="o">(</span><span class="s">&#34;x_axis&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="n">result02_01</span><span class="o">.</span><span class="n">write</span><span class="o">.</span><span class="n">format</span><span class="o">(</span><span class="s">&#34;csv&#34;</span><span class="o">).</span><span class="n">save</span><span class="o">(</span><span class="s">&#34;_&#34;</span><span class="o">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>因此，场景1的计算实际上就是2次Word Count而已，只不过第一次的Word是“carNum”，而第二次的Word是“x_axis”。那么，对于这样的“Word Count”，我们都有哪些调优思路呢？</p>
<p>在配置项调优那一讲，我们专门介绍了Shuffle调优的一些常规方法，比如调整读写缓冲区大小、By Pass排序操作等等。除此之外，我们的脑子里一定要有一根弦：Shuffle的本质是数据的重新分发，凡是有Shuffle操作的地方都需要关注数据分布。所以对于过小的数据分片，我们要有意识地对其进行合并。再者，在案例1中我们提到，applyNumbersDF、luckyDogsDF和applyDistinctDF在后续的案例中会被反复引用，因此给applyDistinctDF加Cache也是一件顺理成章的事情。</p>
<p>调优的思路这么多，那为了演示每一种调优方法的提升效果，我会从常规操作、数据分区合并、加Cache这3个方向出发，分别对场景1进行性能调优。不过，需要说明的是，咱们这么做的目的，一来是为了开阔调优思路，二来是为了复习之前学习过的调优技巧。</p>
<p>当然了，在实际工作中，我们一般没有时间和精力像现在这样，一个方法、一个方法去尝试。那么，效率最高的做法应该是遵循我们一直强调的调优方法论，也就是先去应对木桶的短板、消除瓶颈，优先解决主要矛盾，然后在时间、精力允许的情况下，再去应对次短的木板。</p>
<p>那么问题来了，你认为上述3种调优思路分别应对的是哪些“木板”？这些“木板”中哪一块是最短的？你又会优先采用哪种调优技巧？接下来，我们就带着这些问题，依次对场景1做调优。</p>
<h4 id="思路1shuffle常规优化">思路1：Shuffle常规优化
</h4><p>刚刚咱们提到，Shuffle的常规优化有两类：一类是By Pass排序操作，一类是调整读写缓冲区。而By Pass排序有两个前提条件：一是计算逻辑不涉及聚合或排序；二是Reduce阶段的并行度要小于参数spark.shuffle.sort.bypassMergeThreshold的设置值。显然，场景1不符合要求，计算逻辑既包含聚合也包含排序。所以，我们就只有调整读写缓冲区这一条路可走了。</p>
<p>实际上，读写缓冲区的调优也是有前提的，因为这部分内存消耗会占用Execution Memory内存区域，所以提高缓冲区大小的前提是Execution Memory内存比较充裕。由于咱们使用的硬件资源比较强劲，而且小汽车摇号数据整体体量偏小，因此咱们还是有一些“资本”对读写缓冲区做调优的。具体来说，我们需要调整如下两个配置项：</p>
<ul>
<li><strong>spark.shuffle.file.buffer，Map阶段写入缓冲区大小</strong></li>
<li><strong>spark.reducer.maxSizeInFlight，Reduce阶段读缓冲区大小</strong></li>
</ul>
<p>由于读写缓冲区都是以Task为粒度进行设置的，因此调整这两个参数的时我们要小心一点，一般来说50%往往是个不错的开始，对比基准与优化设置如下表所示。</p>
<p><img src="/p/%E6%89%8B%E6%8A%8A%E6%89%8B%E5%B8%A6%E4%BD%A0%E6%8F%90%E5%8D%87%E5%BA%94%E7%94%A8%E7%9A%84%E6%89%A7%E8%A1%8C%E6%80%A7%E8%83%BD/image-20250413095007223.png"
	width="1590"
	height="316"
	srcset="/p/%E6%89%8B%E6%8A%8A%E6%89%8B%E5%B8%A6%E4%BD%A0%E6%8F%90%E5%8D%87%E5%BA%94%E7%94%A8%E7%9A%84%E6%89%A7%E8%A1%8C%E6%80%A7%E8%83%BD/image-20250413095007223_hu4837364022402970436.png 480w, /p/%E6%89%8B%E6%8A%8A%E6%89%8B%E5%B8%A6%E4%BD%A0%E6%8F%90%E5%8D%87%E5%BA%94%E7%94%A8%E7%9A%84%E6%89%A7%E8%A1%8C%E6%80%A7%E8%83%BD/image-20250413095007223_hu5675522560139212652.png 1024w"
	loading="lazy"
	
		alt="image-20250413095007223"
	
	
		class="gallery-image" 
		data-flex-grow="503"
		data-flex-basis="1207px"
	
></p>
<p>两组对比实验的运行时间，我记录到了下面的表格中。从中我们不难发现，上述两个参数的调整，对于作业端到端执行性能的影响不大。不过，这种参数调了半天，执行效率并没有显著提升的场景，肯定让你似曾相识。这个时候，最好的办法就是我们继续借助“木桶短板”“瓶颈”以及“调优方法论”，去尝试其他的调优思路。</p>
<p><img src="/p/%E6%89%8B%E6%8A%8A%E6%89%8B%E5%B8%A6%E4%BD%A0%E6%8F%90%E5%8D%87%E5%BA%94%E7%94%A8%E7%9A%84%E6%89%A7%E8%A1%8C%E6%80%A7%E8%83%BD/image-20250413095230813.png"
	width="1578"
	height="388"
	srcset="/p/%E6%89%8B%E6%8A%8A%E6%89%8B%E5%B8%A6%E4%BD%A0%E6%8F%90%E5%8D%87%E5%BA%94%E7%94%A8%E7%9A%84%E6%89%A7%E8%A1%8C%E6%80%A7%E8%83%BD/image-20250413095230813_hu13273497280115467077.png 480w, /p/%E6%89%8B%E6%8A%8A%E6%89%8B%E5%B8%A6%E4%BD%A0%E6%8F%90%E5%8D%87%E5%BA%94%E7%94%A8%E7%9A%84%E6%89%A7%E8%A1%8C%E6%80%A7%E8%83%BD/image-20250413095230813_hu4160769378501849223.png 1024w"
	loading="lazy"
	
		alt="image-20250413095230813"
	
	
		class="gallery-image" 
		data-flex-grow="406"
		data-flex-basis="976px"
	
></p>
<h4 id="思路2数据分区合并">思路2：数据分区合并
</h4><p>接着，我们再来说第二个思路，数据分区合并。首先，咱们先来一起分析一下，场景1到底存不存在数据分片过小的问题。为了方便分析，我们再来回顾一遍代码。因为场景1的计算基于数据集applyDistinctDF，所以要回答刚刚的问题，我们需要结合数据集applyDistinctDF的存储大小，以及Shuffle计算过后Reduce阶段的并行度一起来看。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">val</span><span class="w"> </span><span class="n">result02_01</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">applyDistinctDF</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">.</span><span class="na">groupBy</span><span class="p">(</span><span class="n">col</span><span class="p">(</span><span class="s">&#34;carNum&#34;</span><span class="p">))</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">.</span><span class="na">agg</span><span class="p">(</span><span class="n">count</span><span class="p">(</span><span class="n">lit</span><span class="p">(</span><span class="n">1</span><span class="p">)).</span><span class="na">alias</span><span class="p">(</span><span class="s">&#34;x_axis&#34;</span><span class="p">))</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> 
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">.</span><span class="na">groupBy</span><span class="p">(</span><span class="n">col</span><span class="p">(</span><span class="s">&#34;x_axis&#34;</span><span class="p">))</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">.</span><span class="na">agg</span><span class="p">(</span><span class="n">count</span><span class="p">(</span><span class="n">lit</span><span class="p">(</span><span class="n">1</span><span class="p">)).</span><span class="na">alias</span><span class="p">(</span><span class="s">&#34;y_axis&#34;</span><span class="p">))</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> 
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">.</span><span class="na">orderBy</span><span class="p">(</span><span class="s">&#34;x_axis&#34;</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> 
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">result02_01</span><span class="p">.</span><span class="na">write</span><span class="p">.</span><span class="na">format</span><span class="p">(</span><span class="s">&#34;csv&#34;</span><span class="p">).</span><span class="na">save</span><span class="p">(</span><span class="s">&#34;_&#34;</span><span class="p">)</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>并行度由配置项spark.sql.shuffle.partitions决定，其默认大小为200，也就是200个数据分区。而对于数据集存储大小的估算，我们需要用到下面的函数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">def</span><span class="w"> </span><span class="nf">sizeNew</span><span class="p">(</span><span class="n">func</span><span class="p">:</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">DataFrame</span><span class="p">,</span><span class="w"> </span><span class="n">spark</span><span class="p">:</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">SparkSession</span><span class="p">):</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> 
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="n">val</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">func</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> 
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="n">val</span><span class="w"> </span><span class="n">lp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">result</span><span class="p">.</span><span class="na">queryExecution</span><span class="p">.</span><span class="na">logical</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> 
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="n">val</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">spark</span><span class="p">.</span><span class="na">sessionState</span><span class="p">.</span><span class="na">executePlan</span><span class="p">(</span><span class="n">lp</span><span class="p">).</span><span class="na">optimizedPlan</span><span class="p">.</span><span class="na">stats</span><span class="p">.</span><span class="na">sizeInBytes</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> 
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="s">&#34;Estimated size: &#34;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">size</span><span class="o">/</span><span class="n">1024</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&#34;KB&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> 
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>给定DataFrame，sizeNew函数可以返回该数据集在内存中的精确大小。把applyDistinctDF作为实参，调用sizeNew函数，返回的估算尺寸为2.6 GB。将数据集尺寸除以并行度，我们就能得到Reduce阶段每个数据分片的存储大小，也就是13 MB（也就是2.6 GB / 200）。通常来说，数据分片的尺寸大小在200 MB左右为宜，13 MB的分片尺寸显然过小。</p>
<p>在调度系统那一讲（第5讲），我们说过，如果需要处理的数据分片过小，相较于数据处理，Task调度开销将变得异常显著，而这样会导致CPU利用降低，执行性能变差。因此，为了提升CPU利用率进而提升整体的执行效率，我们需要对过小的数据分片做合并。这个时候，AQE的自动分区合并特性就可以帮我们做这件事情。</p>
<p>不过，要想充分利用AQE的自动分区合并特性，我们还需要对相关的配置项进行调整。这里，你直接看场景1是怎么设置这些配置项的就可以了。</p>
<p><img src="/p/%E6%89%8B%E6%8A%8A%E6%89%8B%E5%B8%A6%E4%BD%A0%E6%8F%90%E5%8D%87%E5%BA%94%E7%94%A8%E7%9A%84%E6%89%A7%E8%A1%8C%E6%80%A7%E8%83%BD/image-20250413095428635-4509270.png"
	width="1602"
	height="486"
	srcset="/p/%E6%89%8B%E6%8A%8A%E6%89%8B%E5%B8%A6%E4%BD%A0%E6%8F%90%E5%8D%87%E5%BA%94%E7%94%A8%E7%9A%84%E6%89%A7%E8%A1%8C%E6%80%A7%E8%83%BD/image-20250413095428635-4509270_hu14303222602755076199.png 480w, /p/%E6%89%8B%E6%8A%8A%E6%89%8B%E5%B8%A6%E4%BD%A0%E6%8F%90%E5%8D%87%E5%BA%94%E7%94%A8%E7%9A%84%E6%89%A7%E8%A1%8C%E6%80%A7%E8%83%BD/image-20250413095428635-4509270_hu1006618950429646981.png 1024w"
	loading="lazy"
	
		alt="image-20250413095428635"
	
	
		class="gallery-image" 
		data-flex-grow="329"
		data-flex-basis="791px"
	
></p>
<p>一旦开启AQE机制，自动分区合并特性会自动生效。表格中的配置项有两个需要我们特别注意，一个是最小分区数minPartitionNum，另一个是合并之后的目标尺寸advisoryPartitionSizeInBytes。</p>
<p>我们先来看最小分区数，也就是minPartitionNum。minPartitionNum的含义，指的是分区合并之后的分区数量，不能低于这个参数设置的数值。由于我们计算集群配置的Executors个数为6，为了保证每个CPU都不闲着、有活儿干，我们不妨把minPartitionNum也设置为6。</p>
<p>接下来是分区合并的目标尺寸，我们刚刚说过，分区大小的经验值在200 MB左右，因此我们不妨把advisoryPartitionSizeInBytes设置为200 MB。不过，为了对比不同分区大小对于执行性能的影响，我们可以多做几组实验。</p>
<p>配置项调整前后的几组实验效果对比如下，可以看到，调优后的运行时间有所缩短，这说明分区合并对于提升CPU利用率和作业的整体执行性能是有帮助的。仔细观察下表，我们至少有3点洞察。</p>
<p><img src="/p/%E6%89%8B%E6%8A%8A%E6%89%8B%E5%B8%A6%E4%BD%A0%E6%8F%90%E5%8D%87%E5%BA%94%E7%94%A8%E7%9A%84%E6%89%A7%E8%A1%8C%E6%80%A7%E8%83%BD/image-20250413095510516-4509312.png"
	width="1580"
	height="550"
	srcset="/p/%E6%89%8B%E6%8A%8A%E6%89%8B%E5%B8%A6%E4%BD%A0%E6%8F%90%E5%8D%87%E5%BA%94%E7%94%A8%E7%9A%84%E6%89%A7%E8%A1%8C%E6%80%A7%E8%83%BD/image-20250413095510516-4509312_hu5830753992484060574.png 480w, /p/%E6%89%8B%E6%8A%8A%E6%89%8B%E5%B8%A6%E4%BD%A0%E6%8F%90%E5%8D%87%E5%BA%94%E7%94%A8%E7%9A%84%E6%89%A7%E8%A1%8C%E6%80%A7%E8%83%BD/image-20250413095510516-4509312_hu11529603220882057604.png 1024w"
	loading="lazy"
	
		alt="image-20250413095510516"
	
	
		class="gallery-image" 
		data-flex-grow="287"
		data-flex-basis="689px"
	
></p>
<ul>
<li><strong>并行度过高、数据分片过小，CPU调度开销会变大，执行性能也变差。</strong></li>
<li><strong>分片粒度划分在200 MB左右时，执行性能往往是最优的。</strong></li>
<li><strong>并行度过低、数据分片过大，CPU数据处理开销也会过大，执行性能会锐减。</strong></li>
</ul>
<h4 id="思路3加cache">思路3：加Cache
</h4><p>最后一个思路是加Cache，这个调优技巧使用起来非常简单，我们在案例1已经做过演示，因此，这里直接给出优化代码和运行结果。</p>
<p><img src="/p/%E6%89%8B%E6%8A%8A%E6%89%8B%E5%B8%A6%E4%BD%A0%E6%8F%90%E5%8D%87%E5%BA%94%E7%94%A8%E7%9A%84%E6%89%A7%E8%A1%8C%E6%80%A7%E8%83%BD/image-20250413095605691.png"
	width="1606"
	height="828"
	srcset="/p/%E6%89%8B%E6%8A%8A%E6%89%8B%E5%B8%A6%E4%BD%A0%E6%8F%90%E5%8D%87%E5%BA%94%E7%94%A8%E7%9A%84%E6%89%A7%E8%A1%8C%E6%80%A7%E8%83%BD/image-20250413095605691_hu3500375660281395213.png 480w, /p/%E6%89%8B%E6%8A%8A%E6%89%8B%E5%B8%A6%E4%BD%A0%E6%8F%90%E5%8D%87%E5%BA%94%E7%94%A8%E7%9A%84%E6%89%A7%E8%A1%8C%E6%80%A7%E8%83%BD/image-20250413095605691_hu9884864023486447157.png 1024w"
	loading="lazy"
	
		alt="image-20250413095605691"
	
	
		class="gallery-image" 
		data-flex-grow="193"
		data-flex-basis="465px"
	
></p>
<p>可以看到，利用Cache机制做优化，作业执行性能提升得非常显著。</p>
<p><img src="/p/%E6%89%8B%E6%8A%8A%E6%89%8B%E5%B8%A6%E4%BD%A0%E6%8F%90%E5%8D%87%E5%BA%94%E7%94%A8%E7%9A%84%E6%89%A7%E8%A1%8C%E6%80%A7%E8%83%BD/image-20250413095634677-4509395.png"
	width="1606"
	height="382"
	srcset="/p/%E6%89%8B%E6%8A%8A%E6%89%8B%E5%B8%A6%E4%BD%A0%E6%8F%90%E5%8D%87%E5%BA%94%E7%94%A8%E7%9A%84%E6%89%A7%E8%A1%8C%E6%80%A7%E8%83%BD/image-20250413095634677-4509395_hu1250823513401815348.png 480w, /p/%E6%89%8B%E6%8A%8A%E6%89%8B%E5%B8%A6%E4%BD%A0%E6%8F%90%E5%8D%87%E5%BA%94%E7%94%A8%E7%9A%84%E6%89%A7%E8%A1%8C%E6%80%A7%E8%83%BD/image-20250413095634677-4509395_hu11979244771076088575.png 1024w"
	loading="lazy"
	
		alt="image-20250413095634677"
	
	
		class="gallery-image" 
		data-flex-grow="420"
		data-flex-basis="1009px"
	
></p>
<p>到此为止，我们尝试了3种调优方法来对场景1做性能优化，分别是Shuffle读写缓冲区调整、数据分区合并，以及加Cache。第1种方法针对的是，Shuffle过程中磁盘与网络的请求次数；第2种方法的优化目标，是提升Reduce阶段的CPU利用率；第3种方法针对的是，数据集在磁盘中的重复扫描与重复计算。</p>
<p>实际上，根本不需要做定量分析，仅从定性我们就能看出，数据集的重复扫描与计算的开销最大。因此，在实际工作中，对于类似的“多选题”，我们自然要优先选择能够消除瓶颈的第3种方法。</p>
<h3 id="场景2幸运的中签者">场景2：幸运的中签者
</h3><p>完成了场景1单表Shuffle的优化之后，接下来，我们再来看看场景2，场景2的业务目标是获取中签者的摇号次数分布。我们先来回顾场景2的代码实现，场景2的计算涉及一次数据关联，两次分组、聚合，以及最终的排序操作。不难发现，除了关联计算外，其他计算步骤与场景1如出一辙。因此，对于场景2的优化，我们专注在第一步的数据关联，后续优化沿用场景1的调优方法即可。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">val</span><span class="w"> </span><span class="n">result02_02</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">applyDistinctDF</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">.</span><span class="na">join</span><span class="p">(</span><span class="n">luckyDogsDF</span><span class="p">.</span><span class="na">select</span><span class="p">(</span><span class="s">&#34;carNum&#34;</span><span class="p">),</span><span class="w"> </span><span class="n">Seq</span><span class="p">(</span><span class="s">&#34;carNum&#34;</span><span class="p">),</span><span class="w"> </span><span class="s">&#34;inner&#34;</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">.</span><span class="na">groupBy</span><span class="p">(</span><span class="n">col</span><span class="p">(</span><span class="s">&#34;carNum&#34;</span><span class="p">)).</span><span class="na">agg</span><span class="p">(</span><span class="n">count</span><span class="p">(</span><span class="n">lit</span><span class="p">(</span><span class="n">1</span><span class="p">)).</span><span class="na">alias</span><span class="p">(</span><span class="s">&#34;x_axis&#34;</span><span class="p">))</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">.</span><span class="na">groupBy</span><span class="p">(</span><span class="n">col</span><span class="p">(</span><span class="s">&#34;x_axis&#34;</span><span class="p">)).</span><span class="na">agg</span><span class="p">(</span><span class="n">count</span><span class="p">(</span><span class="n">lit</span><span class="p">(</span><span class="n">1</span><span class="p">)).</span><span class="na">alias</span><span class="p">(</span><span class="s">&#34;y_axis&#34;</span><span class="p">))</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">.</span><span class="na">orderBy</span><span class="p">(</span><span class="s">&#34;x_axis&#34;</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> 
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">result02_02</span><span class="p">.</span><span class="na">write</span><span class="p">.</span><span class="na">format</span><span class="p">(</span><span class="s">&#34;csv&#34;</span><span class="p">).</span><span class="na">save</span><span class="p">(</span><span class="s">&#34;_&#34;</span><span class="p">)</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>参与关联的两张表分别是applyDistinctDF和luckyDogsDF，其中applyDistinctDF是去重之后的摇号数据，luckyDogsDF包含的是中签者的申请编号与批次号。applyDistinctDF包含1.35条数据记录，而luckyDogsDF仅仅包含115万条数据记录。很显然，二者之间的数据关联属于数仓中常见的“大表Join小表”。</p>
<p>遇到“大表Join小表”的计算场景，我们最先应该想到的调优技巧一定是广播变量。毕竟，我们一直都在不遗余力地强调Broadcast Joins的优势与收益。在这里，我再强调一次，你一定要掌握使用广播变量优化数据关联的调优技巧。毫不夸张地说，广播变量是“性价比”最高的调优技巧，且没有之一。</p>
<p>要利用广播变量来优化applyDistinctDF与luckyDogsDF的关联计算，我们需要做两件事情。第一件，估算luckyDogsDF数据表在内存中的存储大小。第二件，设置广播阈值配置项spark.sql.autoBroadcastJoinThreshold。</p>
<p>对于分布式数据集的尺寸预估，我们还是使用sizeNew函数，把luckyDogsDF作为实参，调用sizeNew函数，返回的估算尺寸为18.5MB。有了这个参考值，我们就可以设置广播阈值了。要把applyDistinctDF与luckyDogsDF的关联计算转化为Broadcast Join，只要让广播阈值大于18.5MB就可以，我们不妨把这个参数设置为20MB。</p>
<p><img src="/p/%E6%89%8B%E6%8A%8A%E6%89%8B%E5%B8%A6%E4%BD%A0%E6%8F%90%E5%8D%87%E5%BA%94%E7%94%A8%E7%9A%84%E6%89%A7%E8%A1%8C%E6%80%A7%E8%83%BD/image-20250413095753582-4509474.png"
	width="1584"
	height="308"
	srcset="/p/%E6%89%8B%E6%8A%8A%E6%89%8B%E5%B8%A6%E4%BD%A0%E6%8F%90%E5%8D%87%E5%BA%94%E7%94%A8%E7%9A%84%E6%89%A7%E8%A1%8C%E6%80%A7%E8%83%BD/image-20250413095753582-4509474_hu11308866889565771756.png 480w, /p/%E6%89%8B%E6%8A%8A%E6%89%8B%E5%B8%A6%E4%BD%A0%E6%8F%90%E5%8D%87%E5%BA%94%E7%94%A8%E7%9A%84%E6%89%A7%E8%A1%8C%E6%80%A7%E8%83%BD/image-20250413095753582-4509474_hu12057021047935399441.png 1024w"
	loading="lazy"
	
		alt="image-20250413095753582"
	
	
		class="gallery-image" 
		data-flex-grow="514"
		data-flex-basis="1234px"
	
></p>
<p>我把配置项调整前后的实验结果记录到了如下表格，显然，相比默认的Shuffle Sort Merge Join实现机制，Broadcast Join的执行性能更胜一筹。</p>
<p><img src="/p/%E6%89%8B%E6%8A%8A%E6%89%8B%E5%B8%A6%E4%BD%A0%E6%8F%90%E5%8D%87%E5%BA%94%E7%94%A8%E7%9A%84%E6%89%A7%E8%A1%8C%E6%80%A7%E8%83%BD/image-20250413095812191-4509493.png"
	width="1596"
	height="440"
	srcset="/p/%E6%89%8B%E6%8A%8A%E6%89%8B%E5%B8%A6%E4%BD%A0%E6%8F%90%E5%8D%87%E5%BA%94%E7%94%A8%E7%9A%84%E6%89%A7%E8%A1%8C%E6%80%A7%E8%83%BD/image-20250413095812191-4509493_hu9466953629072805105.png 480w, /p/%E6%89%8B%E6%8A%8A%E6%89%8B%E5%B8%A6%E4%BD%A0%E6%8F%90%E5%8D%87%E5%BA%94%E7%94%A8%E7%9A%84%E6%89%A7%E8%A1%8C%E6%80%A7%E8%83%BD/image-20250413095812191-4509493_hu7607858951518907514.png 1024w"
	loading="lazy"
	
		alt="image-20250413095812191"
	
	
		class="gallery-image" 
		data-flex-grow="362"
		data-flex-basis="870px"
	
></p>
<h2 id="案例3的性能调优中签率的变化趋势">案例3的性能调优：中签率的变化趋势
</h2><p>案例3的业务目标是洞察中签率的变化趋势，我们先来回顾代码。要计算中签率，我们需要分两步走。第一步，按照摇号批次，也就是batchNum分别对applyDistinctDF和luckyDogsDF分组，然后分别对分组内的申请者和中签者做统计计数。第二步，通过数据关联将两类计数做除法，最终得到每个批次的中签率。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="c1">// 统计每批次申请者的人数</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">val</span><span class="w"> </span><span class="n">apply_denominator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">applyDistinctDF</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">.</span><span class="na">groupBy</span><span class="p">(</span><span class="n">col</span><span class="p">(</span><span class="s">&#34;batchNum&#34;</span><span class="p">))</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">.</span><span class="na">agg</span><span class="p">(</span><span class="n">count</span><span class="p">(</span><span class="n">lit</span><span class="p">(</span><span class="n">1</span><span class="p">)).</span><span class="na">alias</span><span class="p">(</span><span class="s">&#34;denominator&#34;</span><span class="p">))</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// 统计每批次中签者的人数</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">val</span><span class="w"> </span><span class="n">lucky_molecule</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">luckyDogsDF</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">.</span><span class="na">groupBy</span><span class="p">(</span><span class="n">col</span><span class="p">(</span><span class="s">&#34;batchNum&#34;</span><span class="p">))</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">.</span><span class="na">agg</span><span class="p">(</span><span class="n">count</span><span class="p">(</span><span class="n">lit</span><span class="p">(</span><span class="n">1</span><span class="p">)).</span><span class="na">alias</span><span class="p">(</span><span class="s">&#34;molecule&#34;</span><span class="p">))</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">val</span><span class="w"> </span><span class="n">result03</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">apply_denominator</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">.</span><span class="na">join</span><span class="p">(</span><span class="n">lucky_molecule</span><span class="p">,</span><span class="w"> </span><span class="n">Seq</span><span class="p">(</span><span class="s">&#34;batchNum&#34;</span><span class="p">),</span><span class="w"> </span><span class="s">&#34;inner&#34;</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">.</span><span class="na">withColumn</span><span class="p">(</span><span class="s">&#34;ratio&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">round</span><span class="p">(</span><span class="n">col</span><span class="p">(</span><span class="s">&#34;molecule&#34;</span><span class="p">)</span><span class="o">/</span><span class="n">col</span><span class="p">(</span><span class="s">&#34;denominator&#34;</span><span class="p">),</span><span class="w"> </span><span class="n">5</span><span class="p">))</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">.</span><span class="na">orderBy</span><span class="p">(</span><span class="s">&#34;batchNum&#34;</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> 
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">result03</span><span class="p">.</span><span class="na">write</span><span class="p">.</span><span class="na">format</span><span class="p">(</span><span class="s">&#34;csv&#34;</span><span class="p">).</span><span class="na">save</span><span class="p">(</span><span class="s">&#34;_&#34;</span><span class="p">)</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>由于2011年到2019年总共有72个摇号批次，因此第一步计算得到结果集，也就是apply_denominator和lucky_molecule各自有72条数据记录。显然，两个如此之小的数据集做关联不存在什么调优空间。</p>
<p>因此，对于案例3来说，调优的关键在于第一步涉及的两个单表Shuffle。关于单表Shuffle的调优思路与技巧，我们在案例2的场景1做过详细的分析与讲解，因此，applyDistinctDF和luckyDogsDF两张表的Shuffle优化就留给你作为课后练习了。</p>
<h2 id="案例4的性能调优中签率局部洞察">案例4的性能调优：中签率局部洞察
</h2><p>与案例3不同，案例4只关注2018年的中签率变化趋势，我们先来回顾案例4的代码实现。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="c1">// 筛选出2018年的中签数据，并按照批次统计中签人数</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">val</span><span class="w"> </span><span class="n">lucky_molecule_2018</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">luckyDogsDF</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">.</span><span class="na">filter</span><span class="p">(</span><span class="n">col</span><span class="p">(</span><span class="s">&#34;batchNum&#34;</span><span class="p">).</span><span class="na">like</span><span class="p">(</span><span class="s">&#34;2018%&#34;</span><span class="p">))</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">.</span><span class="na">groupBy</span><span class="p">(</span><span class="n">col</span><span class="p">(</span><span class="s">&#34;batchNum&#34;</span><span class="p">))</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">.</span><span class="na">agg</span><span class="p">(</span><span class="n">count</span><span class="p">(</span><span class="n">lit</span><span class="p">(</span><span class="n">1</span><span class="p">)).</span><span class="na">alias</span><span class="p">(</span><span class="s">&#34;molecule&#34;</span><span class="p">))</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// 通过与筛选出的中签数据按照批次做关联，计算每期的中签率</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">val</span><span class="w"> </span><span class="n">result04</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">apply_denominator</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">.</span><span class="na">join</span><span class="p">(</span><span class="n">lucky_molecule_2018</span><span class="p">,</span><span class="w"> </span><span class="n">Seq</span><span class="p">(</span><span class="s">&#34;batchNum&#34;</span><span class="p">),</span><span class="w"> </span><span class="s">&#34;inner&#34;</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">.</span><span class="na">withColumn</span><span class="p">(</span><span class="s">&#34;ratio&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">round</span><span class="p">(</span><span class="n">col</span><span class="p">(</span><span class="s">&#34;molecule&#34;</span><span class="p">)</span><span class="o">/</span><span class="n">col</span><span class="p">(</span><span class="s">&#34;denominator&#34;</span><span class="p">),</span><span class="w"> </span><span class="n">5</span><span class="p">))</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">.</span><span class="na">orderBy</span><span class="p">(</span><span class="s">&#34;batchNum&#34;</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> 
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">result04</span><span class="p">.</span><span class="na">write</span><span class="p">.</span><span class="na">format</span><span class="p">(</span><span class="s">&#34;csv&#34;</span><span class="p">).</span><span class="na">save</span><span class="p">(</span><span class="s">&#34;_&#34;</span><span class="p">)</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>从代码实现来看，案例4相比案例3唯一的改动，就是在luckyDogsDF做统计计数之前增加了摇号批次的过滤条件，也就是filter(col(“batchNum”).like(“2018%”))。你可能会说：“案例4的改动可以说是微乎其微，它的调优空间和调优方法应该和案例3没啥区别”。还真不是，还记得Spark 3.0推出的DPP新特性吗？添加在luckyDogsDF表上的这个不起眼的过滤谓词，恰恰让DPP有了用武之地。</p>
<p>在DPP那一讲，我们介绍过开启DPP的3个前提条件：</p>
<ul>
<li>事实表必须是分区表，且分区字段（可以是多个）必须包含Join Key</li>
<li>DPP仅支持等值Joins，不支持大于、小于这种不等值关联关系</li>
<li>维表过滤之后的数据集，必须要小于广播阈值，因此，你要注意调整配置项spark.sql.autoBroadcastJoinThreshold</li>
</ul>
<p>那么，这3个前提条件是怎么影响案例4的性能调优的呢？</p>
<p>首先，在上一讲，我们介绍过摇号数据的目录结构，apply和lucky目录下的数据都按照batchNum列做了分区存储。因此，案例4中参与关联的数据表applyDistinctDF和luckyDogsDF都是分区表，且分区键batchNum刚好是二者做关联计算的Join Key。其次，案例4中的关联计算显然是等值Join。</p>
<p>最后，我们只要保证lucky_molecule_2018结果集小于广播阈值就可以触发DPP机制。2018年只有6次摇号，也就是说，分组计数得到的lucky_molecule_2018只有6条数据记录，这么小的“数据集”完全可以放进广播变量。</p>
<p>如此一来，案例4满足了DPP所有的前提条件，利用DPP机制，我们就可以减少applyDistinctDF的数据扫描量，从而在整体上提升作业的执行性能。</p>
<p><img src="/p/%E6%89%8B%E6%8A%8A%E6%89%8B%E5%B8%A6%E4%BD%A0%E6%8F%90%E5%8D%87%E5%BA%94%E7%94%A8%E7%9A%84%E6%89%A7%E8%A1%8C%E6%80%A7%E8%83%BD/image-20250413100522049-4509923.png"
	width="1592"
	height="476"
	srcset="/p/%E6%89%8B%E6%8A%8A%E6%89%8B%E5%B8%A6%E4%BD%A0%E6%8F%90%E5%8D%87%E5%BA%94%E7%94%A8%E7%9A%84%E6%89%A7%E8%A1%8C%E6%80%A7%E8%83%BD/image-20250413100522049-4509923_hu922719157353639088.png 480w, /p/%E6%89%8B%E6%8A%8A%E6%89%8B%E5%B8%A6%E4%BD%A0%E6%8F%90%E5%8D%87%E5%BA%94%E7%94%A8%E7%9A%84%E6%89%A7%E8%A1%8C%E6%80%A7%E8%83%BD/image-20250413100522049-4509923_hu10716624258416527384.png 1024w"
	loading="lazy"
	
		alt="image-20250413100522049"
	
	
		class="gallery-image" 
		data-flex-grow="334"
		data-flex-basis="802px"
	
></p>
<p>DPP的核心作用在于降低事实表applyDistinctDF的磁盘扫描量，因此案例4的调优办法非常简单，只要把最初加在applyDistinctDF之上的Cache去掉即可，如上表右侧所示。同时，为了公平起见，对比基准不应该仅仅是让DPP失效的测试用例，而应该是applyDistinctDF加Cache的测试用例。与此同时，我们直接对比DPP的磁盘读取效率与Cache的内存读取效率，也能加深对DPP机制的认知与理解。</p>
<p>把上述两个测试用例交付执行，运行结果如下。可以看到，相较对比基准，在DPP机制的作用下，案例4端到端的执行性能有着将近5倍的提升。由此可见，数据集加Cache之后的内存读取，远不如DPP机制下的磁盘读取更高效。</p>
<p><img src="/p/%E6%89%8B%E6%8A%8A%E6%89%8B%E5%B8%A6%E4%BD%A0%E6%8F%90%E5%8D%87%E5%BA%94%E7%94%A8%E7%9A%84%E6%89%A7%E8%A1%8C%E6%80%A7%E8%83%BD/image-20250413100509354-4509911.png"
	width="1600"
	height="446"
	srcset="/p/%E6%89%8B%E6%8A%8A%E6%89%8B%E5%B8%A6%E4%BD%A0%E6%8F%90%E5%8D%87%E5%BA%94%E7%94%A8%E7%9A%84%E6%89%A7%E8%A1%8C%E6%80%A7%E8%83%BD/image-20250413100509354-4509911_hu1701982457055427767.png 480w, /p/%E6%89%8B%E6%8A%8A%E6%89%8B%E5%B8%A6%E4%BD%A0%E6%8F%90%E5%8D%87%E5%BA%94%E7%94%A8%E7%9A%84%E6%89%A7%E8%A1%8C%E6%80%A7%E8%83%BD/image-20250413100509354-4509911_hu12980775000504951598.png 1024w"
	loading="lazy"
	
		alt="image-20250413100509354"
	
	
		class="gallery-image" 
		data-flex-grow="358"
		data-flex-basis="860px"
	
></p>
<h2 id="案例5的性能调优倍率分析">案例5的性能调优：倍率分析
</h2><p>案例5也包含两个场景，场景1的业务目标是计算不同倍率下的中签人数，场景2与场景1相比稍有不同，它的目的是计算不同倍率下的中签比例。</p>
<p>尽管两个场景的计算逻辑有区别，但是调优思路与方法是一致的。因此，在案例5中，我们只需要对场景1的性能优化进行探讨、分析与对比，我们先来回顾一下场景1的代码实现。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">val</span><span class="w"> </span><span class="n">result05_01</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">applyNumbersDF</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">.</span><span class="na">join</span><span class="p">(</span><span class="n">luckyDogsDF</span><span class="p">.</span><span class="na">filter</span><span class="p">(</span><span class="n">col</span><span class="p">(</span><span class="s">&#34;batchNum&#34;</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="s">&#34;201601&#34;</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">.</span><span class="na">select</span><span class="p">(</span><span class="s">&#34;carNum&#34;</span><span class="p">),</span><span class="w"> </span><span class="n">Seq</span><span class="p">(</span><span class="s">&#34;carNum&#34;</span><span class="p">),</span><span class="w"> </span><span class="s">&#34;inner&#34;</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">.</span><span class="na">groupBy</span><span class="p">(</span><span class="n">col</span><span class="p">(</span><span class="s">&#34;batchNum&#34;</span><span class="p">),</span><span class="n">col</span><span class="p">(</span><span class="s">&#34;carNum&#34;</span><span class="p">))</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">.</span><span class="na">agg</span><span class="p">(</span><span class="n">count</span><span class="p">(</span><span class="n">lit</span><span class="p">(</span><span class="n">1</span><span class="p">)).</span><span class="na">alias</span><span class="p">(</span><span class="s">&#34;multiplier&#34;</span><span class="p">))</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">.</span><span class="na">groupBy</span><span class="p">(</span><span class="s">&#34;carNum&#34;</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">.</span><span class="na">agg</span><span class="p">(</span><span class="n">max</span><span class="p">(</span><span class="s">&#34;multiplier&#34;</span><span class="p">).</span><span class="na">alias</span><span class="p">(</span><span class="s">&#34;multiplier&#34;</span><span class="p">))</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">.</span><span class="na">groupBy</span><span class="p">(</span><span class="s">&#34;multiplier&#34;</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">.</span><span class="na">agg</span><span class="p">(</span><span class="n">count</span><span class="p">(</span><span class="n">lit</span><span class="p">(</span><span class="n">1</span><span class="p">)).</span><span class="na">alias</span><span class="p">(</span><span class="s">&#34;cnt&#34;</span><span class="p">))</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">.</span><span class="na">orderBy</span><span class="p">(</span><span class="s">&#34;multiplier&#34;</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> 
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">result05_01</span><span class="p">.</span><span class="na">write</span><span class="p">.</span><span class="na">format</span><span class="p">(</span><span class="s">&#34;csv&#34;</span><span class="p">).</span><span class="na">save</span><span class="p">(</span><span class="s">&#34;_&#34;</span><span class="p">)</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>仔细研读代码之后，我们发现场景1的计算分为如下几个环节：</p>
<ul>
<li>大表与小表的关联计算，且小表带过滤条件</li>
<li>按batchNum列做统计计数</li>
<li>按carNum列取最大值</li>
<li>按multiplier列做统计计数</li>
</ul>
<p>在这4个环节当中，关联计算涉及的数据扫描量和数据处理量最大。因此，这一环节是案例5执行效率的关键所在。另外，除了关联计算环节，其他3个环节都属于单表Shuffle优化的范畴，这3个环节的优化可以参考案例2场景1的调优思路与技巧，咱们也不多说了。因此，对于案例5的性能优化，我们重点关注第一个环节，也就是applyNumbersDF与luckyDogsDF的关联计算。</p>
<p>仔细观察第一个环节的关联计算，我们发现关联条件中的Join Key是carNum，而carNum并不是applyNumbersDF与luckyDogsDF两张表的分区键，因此，在这个关联查询中，我们没有办法利用DPP机制去做优化。</p>
<p>不过，applyNumbersDF与luckyDogsDF的内关联是典型的“大表Join小表”，对于这种场景，我们至少有两种方法可以将低效的SMJ转化为高效的BHJ。</p>
<p>第一种办法是计算原始数据集luckyDogsDF的内存存储大小，确保其小于广播阈值，从而利用Spark SQL的静态优化机制将SMJ转化为BHJ。第二种方法是确保过滤后的luckyDogsDF小于广播阈值，这样我们就可以利用Spark SQL的AQE机制来动态地将SMJ转化为BHJ。</p>
<p>接下来，我们分别使用这两种方法来做优化，比较它们之间，以及它们与对比基准之间的性能差异。在案例2场景2中，我们计算过luckyDogsDF在内存中的存储大小是18.5MB，因此，通过适当调节spark.sql.autoBroadcastJoinThreshold，我们就可以灵活地在两种调优方法之间进行切换。</p>
<p><img src="/p/%E6%89%8B%E6%8A%8A%E6%89%8B%E5%B8%A6%E4%BD%A0%E6%8F%90%E5%8D%87%E5%BA%94%E7%94%A8%E7%9A%84%E6%89%A7%E8%A1%8C%E6%80%A7%E8%83%BD/image-20250413100153635.png"
	width="1608"
	height="370"
	srcset="/p/%E6%89%8B%E6%8A%8A%E6%89%8B%E5%B8%A6%E4%BD%A0%E6%8F%90%E5%8D%87%E5%BA%94%E7%94%A8%E7%9A%84%E6%89%A7%E8%A1%8C%E6%80%A7%E8%83%BD/image-20250413100153635_hu6360441420781906689.png 480w, /p/%E6%89%8B%E6%8A%8A%E6%89%8B%E5%B8%A6%E4%BD%A0%E6%8F%90%E5%8D%87%E5%BA%94%E7%94%A8%E7%9A%84%E6%89%A7%E8%A1%8C%E6%80%A7%E8%83%BD/image-20250413100153635_hu12605627327634959688.png 1024w"
	loading="lazy"
	
		alt="image-20250413100153635"
	
	
		class="gallery-image" 
		data-flex-grow="434"
		data-flex-basis="1043px"
	
></p>
<p>将3种测试用例付诸执行，在执行效率方面，SMJ毫无悬念是最差的，而AQE的动态优化介于SMJ与Spark SQL的静态转化之间。毕竟，AQE的Join策略调整是一种“亡羊补牢、犹未为晚”的优化机制，在把SMJ调整为BHJ之前，参与Join的两张表的Shuffle计算已经执行过半。因此，它的执行效率一定比Spark SQL的静态优化更差。尽管如此，AQE动态调整过后的BHJ还是比默认的SMJ要高效得多，而这也体现了AQE优化机制的价值所在。</p>
<p><img src="/p/%E6%89%8B%E6%8A%8A%E6%89%8B%E5%B8%A6%E4%BD%A0%E6%8F%90%E5%8D%87%E5%BA%94%E7%94%A8%E7%9A%84%E6%89%A7%E8%A1%8C%E6%80%A7%E8%83%BD/image-20250413100214073-4509735.png"
	width="1596"
	height="456"
	srcset="/p/%E6%89%8B%E6%8A%8A%E6%89%8B%E5%B8%A6%E4%BD%A0%E6%8F%90%E5%8D%87%E5%BA%94%E7%94%A8%E7%9A%84%E6%89%A7%E8%A1%8C%E6%80%A7%E8%83%BD/image-20250413100214073-4509735_hu1029878328910484258.png 480w, /p/%E6%89%8B%E6%8A%8A%E6%89%8B%E5%B8%A6%E4%BD%A0%E6%8F%90%E5%8D%87%E5%BA%94%E7%94%A8%E7%9A%84%E6%89%A7%E8%A1%8C%E6%80%A7%E8%83%BD/image-20250413100214073-4509735_hu9338572866641015106.png 1024w"
	loading="lazy"
	
		alt="image-20250413100214073"
	
	
		class="gallery-image" 
		data-flex-grow="350"
		data-flex-basis="840px"
	
></p>
<h2 id="总结">总结
</h2><p>今天这一讲，我们结合以前学过的知识点与调优技巧，以小汽车摇号为例Case By Case地做性能优化。涉及的优化技巧有Shuffle读写缓冲区调整、加Cache、预估数据集存储大小、Spark SQL静态优化、AQE动态优化（自动分区合并与Join策略调整）以及DPP机制。为了方便你对比，我把它们总结在了一张脑图里。不过，我更希望你能自己总结一下，这样才能记得更好。</p>
<p><img src="/p/%E6%89%8B%E6%8A%8A%E6%89%8B%E5%B8%A6%E4%BD%A0%E6%8F%90%E5%8D%87%E5%BA%94%E7%94%A8%E7%9A%84%E6%89%A7%E8%A1%8C%E6%80%A7%E8%83%BD/image-20250413100248830-4509770.png"
	width="1630"
	height="286"
	srcset="/p/%E6%89%8B%E6%8A%8A%E6%89%8B%E5%B8%A6%E4%BD%A0%E6%8F%90%E5%8D%87%E5%BA%94%E7%94%A8%E7%9A%84%E6%89%A7%E8%A1%8C%E6%80%A7%E8%83%BD/image-20250413100248830-4509770_hu8754687488732352479.png 480w, /p/%E6%89%8B%E6%8A%8A%E6%89%8B%E5%B8%A6%E4%BD%A0%E6%8F%90%E5%8D%87%E5%BA%94%E7%94%A8%E7%9A%84%E6%89%A7%E8%A1%8C%E6%80%A7%E8%83%BD/image-20250413100248830-4509770_hu3164633295090456417.png 1024w"
	loading="lazy"
	
		alt="image-20250413100248830"
	
	
		class="gallery-image" 
		data-flex-grow="569"
		data-flex-basis="1367px"
	
></p>

</section>


    <footer class="article-footer">
    

    </footer>


    
</article>

    

    

<aside class="related-content--wrapper">
    <h2 class="section-title">相关文章</h2>
    <div class="related-content">
        <div class="flex article-list--tile">
            
                
<article class="has-image">
    <a href="/p/%E8%B0%83%E5%BA%A6%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8%E8%AE%B2%E8%A7%A3/">
        
        
            <div class="article-image">
                <img src="/p/%E8%B0%83%E5%BA%A6%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8%E8%AE%B2%E8%A7%A3/lizard-8007238_1280.99221b6ddc6adbd3b3d4b2a2ff222b99_hu9270167774858500963.jpg" 
                        width="250" 
                        height="150" 
                        loading="lazy"
                        alt="Featured image of post 调度系统入门讲解"
                        
                        data-hash="md5-mSIbbdxq29Oz1LKi/yIrmQ==">
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">调度系统入门讲解</h2>
        </div>
    </a>
</article>

            
                
<article class="has-image">
    <a href="/p/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E4%B9%8Bjob%E4%BC%98%E5%8C%96/">
        
        
            <div class="article-image">
                <img src="/p/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E4%B9%8Bjob%E4%BC%98%E5%8C%96/paddle-boat-8253274_1280.f75fabdedeae0941d378faac2224d26d_hu17172630445701689797.jpg" 
                        width="250" 
                        height="150" 
                        loading="lazy"
                        alt="Featured image of post 性能调优之Job优化"
                        
                        data-hash="md5-91&#43;r3t6uCUHTePqsIiTSbQ==">
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">性能调优之Job优化</h2>
        </div>
    </a>
</article>

            
                
<article class="has-image">
    <a href="/p/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%80%BE%E6%96%9C/">
        
        
            <div class="article-image">
                <img src="/p/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%80%BE%E6%96%9C/gannet-9003524_1280.aa511a7310cfa3385af52b3a0fffbbde_hu3687632605550775934.jpg" 
                        width="250" 
                        height="150" 
                        loading="lazy"
                        alt="Featured image of post 性能调优之数据倾斜"
                        
                        data-hash="md5-qlEacxDPozha9Ss6D/&#43;73g==">
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">性能调优之数据倾斜</h2>
        </div>
    </a>
</article>

            
                
<article class="has-image">
    <a href="/p/blockmanager%E7%AE%A1%E7%90%86%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">
        
        
            <div class="article-image">
                <img src="/p/blockmanager%E7%AE%A1%E7%90%86%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/dolphin-8949505_1280.b851b2721acfbb3b660cb93a718d57d3_hu5252129146125328555.jpg" 
                        width="250" 
                        height="150" 
                        loading="lazy"
                        alt="Featured image of post BlockManager管理源码解析"
                        
                        data-hash="md5-uFGychrPuztmDLk6cY1X0w==">
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">BlockManager管理源码解析</h2>
        </div>
    </a>
</article>

            
                
<article class="has-image">
    <a href="/p/spark%E5%B9%BF%E6%92%AD%E6%9C%BA%E5%88%B6%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0/">
        
        
            <div class="article-image">
                <img src="/p/spark%E5%B9%BF%E6%92%AD%E6%9C%BA%E5%88%B6%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0/grebe-7972183_1280.6dd8a2d7b8cf99148cf7a877d9459ae8_hu10399000877992530385.jpg" 
                        width="250" 
                        height="150" 
                        loading="lazy"
                        alt="Featured image of post Spark广播机制源码实现"
                        
                        data-hash="md5-bdii17jPmRSM96h32UWa6A==">
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">Spark广播机制源码实现</h2>
        </div>
    </a>
</article>

            
        </div>
    </div>
</aside>

     
    
        
    <script src="https://utteranc.es/client.js" 
        repo="sherlock-lin/utterances-comments"
        issue-term="pathname"
        
        crossorigin="anonymous"
        async
        >
</script>

<style>
    .utterances {
        max-width: unset;
    }
</style>

<script>
    let utterancesLoaded = false;

    function setUtterancesTheme(theme) {
        let utterances = document.querySelector('.utterances iframe');
        if (utterances) {
            utterances.contentWindow.postMessage(
                {
                    type: 'set-theme',
                    theme: `github-${theme}`
                },
                'https://utteranc.es'
            );
        }
    }

    addEventListener('message', event => {
        if (event.origin !== 'https://utteranc.es') return;

        
        utterancesLoaded = true;
        setUtterancesTheme(document.documentElement.dataset.scheme)
    });

    window.addEventListener('onColorSchemeChange', (e) => {
        if (!utterancesLoaded) return;
        setUtterancesTheme(e.detail)
    })
</script>


    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
            2022 - 
        
        2025 sherlock-lin
    </section>
    
    <section class="powerby">
        使用 <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> 构建 <br />
        主题 <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="3.27.0">Stack</a></b> 由 <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a> 设计
    </section>
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_pv">本站总访问量 <span id="busuanzi_value_site_pv"></span> 次 · </span>
<span id="busuanzi_container_site_uv">您是本站第 <span id="busuanzi_value_site_uv"></span> 位访问者</span>
</footer>


    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css"crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css"crossorigin="anonymous"
            >

            </main>
        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js"integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z&#43;KMkF24hUW8WePSA9HM="crossorigin="anonymous"
                
                >
            </script><script type="text/javascript" src="/ts/main.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>

    </body>
</html>
